<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Serpent | Fong Family Arcade</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        body {
            background-color: #240a1e; 
            color: #ff66ff;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            height: 100dvh; 
            margin: 0;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        /* --- HEADER --- */
        .game-header {
            width: 100%;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid currentColor;
            flex-shrink: 0;
            z-index: 10;
            height: 60px; /* Fixed height for calc */
        }
        
        .back-btn {
            text-decoration: none;
            font-size: 1.2rem;
            color: inherit;
            opacity: 0.8;
            font-weight: bold;
        }

        .title-group { text-align: right; }
        .game-title {
            margin: 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 8px currentColor;
        }
        .score-display {
            font-size: 1.1rem;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
        }

        /* --- STAGE --- */
        .game-stage {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
            min-height: 0; 
            z-index: 1;
        }

        .canvas-wrapper {
            position: relative;
            padding: 4px;
            border-radius: 8px;
            box-shadow: 0 0 25px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        canvas {
            background: #000;
            display: block;
            border-radius: 4px;
        }

        /* --- CONTROLS --- */
        .controls-area {
            width: 100%;
            height: 120px; 
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
            /* Extra padding for iPhone Home Bar */
            padding-bottom: env(safe-area-inset-bottom, 20px); 
            box-sizing: content-box; /* Ensures padding adds to height */
            flex-shrink: 0;
            z-index: 100;
        }

        /* DESKTOP MODE: Hide controls on screens wider than 1024px */
        @media (min-width: 1024px) {
            .controls-area {
                display: none !important;
            }
        }

        .control-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid;
            font-size: 2.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.1s;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .control-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.3); }

        /* --- OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            display: none; 
            padding: 20px;
            text-align: center;
        }
        .overlay.active { display: flex; }

        .overlay h2 {
            font-size: 3rem;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            font-style: italic;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            border: none;
            color: #000;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
            transition: transform 0.1s;
            margin-top: 10px;
        }
        .start-btn:active { transform: scale(0.95); }

        /* --- MODE SELECTOR --- */
        .mode-container {
            margin-bottom: 20px;
            width: 100%;
            max-width: 320px;
        }

        .mode-selector {
            display: flex;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 4px;
            gap: 4px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px 5px;
            background: transparent;
            border: none;
            color: #aaa;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            text-transform: uppercase;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .mode-btn.active {
            background: #fff;
            color: #000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .mode-desc {
            margin-top: 15px;
            font-size: 0.9rem;
            color: rgba(255,255,255,0.8);
            font-style: italic;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- THEMES --- */
        body.theme-neon { background-color: #240a1e; color: #ff66ff; }
        .theme-neon .canvas-wrapper { background: linear-gradient(135deg, #ff00cc, #9900ff); }
        .theme-neon canvas { 
            background-image: linear-gradient(#2a0a2e 1px, transparent 1px), linear-gradient(90deg, #2a0a2e 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .theme-neon .start-btn { background: #ff00cc; color: #fff; box-shadow: 0 0 20px #ff00cc; }
        .theme-neon .control-btn { border-color: #ff00cc; color: #ff00cc; }

        body.theme-retro { background-color: #333; color: #fff; font-family: 'Courier New', monospace; }
        .theme-retro .game-header { background: #000; border-color: #fff; }
        .theme-retro .canvas-wrapper { background: #fff; padding: 2px; box-shadow: none; border-radius: 0; }
        .theme-retro canvas { background: #000; border-radius: 0; background-image: none; }
        .theme-retro .game-title { color: #fff; text-shadow: none; }
        .theme-retro .start-btn { background: #fff; color: #000; clip-path: none; border-radius: 0; box-shadow: none; }
        .theme-retro .control-btn { border: 2px solid #fff; color: #fff; border-radius: 0; background: #000; }
        .theme-retro .mode-btn.active { background: #fff; color: #000; }

        body.theme-chameleon { background-color: #0a1e24; color: #00ffcc; }
        .theme-chameleon .canvas-wrapper { background: linear-gradient(135deg, #00ffcc, #00ff66); }
        .theme-chameleon canvas { 
            background-image: linear-gradient(#022e2a 1px, transparent 1px), linear-gradient(90deg, #022e2a 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .theme-chameleon .start-btn { background: #00ffcc; color: #000; box-shadow: 0 0 20px #00ffcc; }
        .theme-chameleon .control-btn { border-color: #00ffcc; color: #00ffcc; }
        .theme-chameleon .game-title { color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }

    </style>
</head>
<body class="theme-neon">

    <header class="game-header">
        <a href="../../index.html" class="back-btn">← Arcade</a>
        <div class="title-group">
            <h1 class="game-title">Neon Serpent</h1>
            <div class="score-display">SCORE: <span id="score">0</span></div>
        </div>
    </header>

    <div class="game-stage">
        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            
            <div id="gameOverScreen" class="overlay">
                <h2>CRASHED</h2>
                <div style="margin-bottom: 20px; font-size: 1.2rem; color: inherit;">Score: <span id="finalScore">0</span></div>
                <button id="retryBtn" class="start-btn">RETRY</button>
            </div>

            <div id="startScreen" class="overlay active" style="background: rgba(0,0,0,0.6);">
                <div style="margin-bottom:10px; font-weight:bold; letter-spacing:1px; color:inherit; opacity:0.8;">SELECT MODE</div>
                
                <div class="mode-container">
                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="setMode('neon')">Neon</button>
                        <button class="mode-btn" onclick="setMode('chameleon')">Color Eater</button>
                        <button class="mode-btn" onclick="setMode('retro')">B&W</button>
                    </div>
                    <div id="modeDesc" class="mode-desc">
                        Classic arcade action with a cyber glow.
                    </div>
                </div>

                <button id="startBtn" class="start-btn">PLAY</button>
            </div>
        </div>
    </div>

    <div class="controls-area">
        <button class="control-btn" id="btnLeft">↶</button>
        <button class="control-btn" id="btnRight">↷</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startScreen = document.getElementById('startScreen');
        const modeDesc = document.getElementById('modeDesc');
        const controlsArea = document.querySelector('.controls-area');
        const body = document.body;

        let snake, direction, food, score, gameLoop, isGameOver;
        let isAttractMode = false; 
        let pendingDirection;
        let currentMode = 'neon'; 
        let activeColor = '#ffffff';

        const PALETTE = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800'];
        const tileCount = 20; 
        let gridSize; 
        
        const DESCRIPTIONS = {
            neon: "Classic arcade action with a cyber glow.",
            chameleon: "You are what you eat! Change colors instantly.",
            retro: "Old school purity. No effects, just skill."
        };

        function resize() {
            // Logic Check: Are buttons hidden?
            const controlsHidden = getComputedStyle(controlsArea).display === 'none';
            
            // Calculate height buffers
            const headerHeight = 60;
            // IMPORTANT: Increased buffer from 120 -> 160 to account for Safe Area Inset padding
            const controlsHeight = controlsHidden ? 0 : 160; 
            const padding = 20;

            const availableHeight = window.innerHeight - (headerHeight + controlsHeight + padding);
            const availableWidth = window.innerWidth - 40;
            
            // Max size limit
            const maxSize = controlsHidden ? 600 : 400;

            const size = Math.min(availableWidth, availableHeight, maxSize); 
            
            canvas.width = size;
            canvas.height = size;
            gridSize = size / tileCount;

            if(snake) draw(); 
        }
        window.addEventListener('resize', resize);
        resize(); 

        window.setMode = function(mode) {
            currentMode = mode;
            body.className = `theme-${mode}`;
            modeDesc.textContent = DESCRIPTIONS[mode];

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if(mode === 'neon' && btn.textContent === 'Neon') btn.classList.add('active');
                if(mode === 'chameleon' && btn.textContent === 'Color Eater') btn.classList.add('active');
                if(mode === 'retro' && btn.textContent === 'B&W') btn.classList.add('active');
            });

            const title = document.querySelector('.game-title');
            if(mode === 'neon') title.textContent = "Neon Serpent";
            if(mode === 'retro') title.textContent = "Snake_V1.0";
            if(mode === 'chameleon') title.textContent = "Color Eater";
            
            startAttractMode();
        }

        function resetState() {
            const startColor = currentMode === 'chameleon' ? '#ffffff' : null;
            snake = [
                { x: 10, y: 15, color: startColor },
                { x: 10, y: 16, color: startColor },
                { x: 10, y: 17, color: startColor }
            ];
            direction = { x: 0, y: -1 }; 
            pendingDirection = { x: 0, y: -1 };
            activeColor = '#ffffff';
            food = randomFood(); 
            score = 0;
            scoreEl.textContent = 0;
            isGameOver = false;
        }

        function initGame() {
            isAttractMode = false; 
            resetState();
            gameOverScreen.classList.remove('active');
            startScreen.classList.remove('active');
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(gameTick, 110); 
        }

        function startAttractMode() {
            isAttractMode = true;
            resetState();
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(gameTick, 80); 
        }

        function randomFood() {
            let newFood;
            while (true) {
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    color: PALETTE[Math.floor(Math.random() * PALETTE.length)]
                };
                if (!snake.some(seg => seg.x === newFood.x && seg.y === newFood.y)) {
                    return newFood;
                }
            }
        }

        function getBotMove() {
            const head = snake[0];
            const moves = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }
            ];
            const validMoves = moves.filter(m => {
                const nx = head.x + m.x;
                const ny = head.y + m.y;
                if (nx < 0 || nx >= tileCount || ny < 0 || ny >= tileCount) return false;
                if (snake.some(s => s.x === nx && s.y === ny)) return false;
                if (m.x === -direction.x && m.y === -direction.y) return false;
                return true;
            });
            if (validMoves.length === 0) return direction; 
            validMoves.sort((a, b) => {
                const distA = Math.abs((head.x + a.x) - food.x) + Math.abs((head.y + a.y) - food.y);
                const distB = Math.abs((head.x + b.x) - food.x) + Math.abs((head.y + b.y) - food.y);
                return distA - distB;
            });
            return validMoves[0];
        }

        function gameTick() {
            if (isAttractMode) {
                direction = getBotMove();
            } else {
                direction = pendingDirection;
            }

            const head = { 
                x: snake[0].x + direction.x, 
                y: snake[0].y + direction.y,
                color: activeColor 
            };

            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount || 
                snake.some(seg => seg.x === head.x && seg.y === head.y)) {
                if (isAttractMode) {
                    startAttractMode(); 
                    return;
                } else {
                    return endGame();
                }
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                if (!isAttractMode) {
                    score++;
                    scoreEl.textContent = score;
                    if(navigator.vibrate) navigator.vibrate(50);
                }
                if (currentMode === 'chameleon') {
                    activeColor = food.color;
                    snake[0].color = activeColor; 
                }
                food = randomFood();
            } else {
                snake.pop();
            }

            draw();
        }

        function draw() {
            if(!snake) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            snake.forEach((seg, i) => {
                let fill, blur, shadowColor;
                if (currentMode === 'retro') {
                    fill = '#ffffff'; blur = 0;
                } else if (currentMode === 'chameleon') {
                    fill = seg.color || '#fff'; blur = 10; shadowColor = fill;
                } else {
                    if (i === 0) {
                        fill = '#ffffff'; blur = 20; shadowColor = "#ff00cc";
                    } else {
                        const hue = 320 - (i * 4); 
                        fill = `hsl(${hue}, 100%, 50%)`;
                        blur = 10; shadowColor = fill;
                    }
                }
                ctx.fillStyle = fill;
                if(currentMode !== 'retro') {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = shadowColor;
                }
                ctx.fillRect(seg.x * gridSize + 1, seg.y * gridSize + 1, gridSize - 2, gridSize - 2);
            });

            ctx.shadowBlur = 0;
            let foodFill;
            if (currentMode === 'retro') {
                foodFill = '#ffffff';
            } else if (currentMode === 'chameleon') {
                foodFill = food ? food.color : '#fff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = foodFill;
            } else {
                foodFill = '#00ffff'; 
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#00ffff";
            }
            ctx.fillStyle = foodFill;
            if (currentMode === 'retro') {
                if(food) ctx.fillRect(food.x * gridSize + 4, food.y * gridSize + 4, gridSize - 8, gridSize - 8);
            } else {
                ctx.beginPath();
                const cx = food ? food.x * gridSize + gridSize/2 : 0;
                const cy = food ? food.y * gridSize + gridSize/2 : 0;
                ctx.arc(cx, cy, gridSize/2 - 4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        }

        function endGame() {
            clearInterval(gameLoop);
            isGameOver = true;
            if(navigator.vibrate) navigator.vibrate(300);
            finalScoreEl.textContent = score;
            gameOverScreen.classList.add('active');
        }

        function turnLeft() {
            if (isGameOver || isAttractMode) return;
            const newDir = { x: direction.y, y: -direction.x };
            pendingDirection = newDir;
        }

        function turnRight() {
            if (isGameOver || isAttractMode) return;
            const newDir = { x: -direction.y, y: direction.x };
            pendingDirection = newDir;
        }

        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');

        btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); turnLeft(); });
        btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); turnRight(); });
        btnLeft.addEventListener('mousedown', turnLeft);
        btnRight.addEventListener('mousedown', turnRight);

        document.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft') turnLeft();
            if(e.key === 'ArrowRight') turnRight();
        });

        document.getElementById('startBtn').addEventListener('click', initGame);
        document.getElementById('retryBtn').addEventListener('click', () => {
            gameOverScreen.classList.remove('active');
            startScreen.classList.add('active');
            startAttractMode(); 
        });

        startAttractMode();

    </script>
</body>
</html>