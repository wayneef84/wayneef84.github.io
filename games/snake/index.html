<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Serpent | F.O.N.G.</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        body {
            background-color: #240a1e; 
            color: #ff66ff;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            height: 100dvh; 
            margin: 0;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        /* --- HEADER --- */
        .game-header {
            width: 100%;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid currentColor;
            flex-shrink: 0;
            z-index: 10;
            height: 60px; /* Fixed height for calc */
        }
        
        .back-btn {
            text-decoration: none;
            font-size: 1.2rem;
            color: inherit;
            opacity: 0.8;
            font-weight: bold;
        }

        .title-group { text-align: right; }
        .game-title {
            margin: 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 8px currentColor;
        }
        .score-display {
            font-size: 1.1rem;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
        }

        /* --- STAGE --- */
        .game-stage {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
            min-height: 0; 
            z-index: 1;
        }

        .canvas-wrapper {
            position: relative;
            padding: 4px;
            border-radius: 8px;
            box-shadow: 0 0 25px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        canvas {
            background: #000;
            display: block;
            border-radius: 4px;
        }

        /* --- CONTROLS --- */
        .controls-area {
            width: 100%;
            height: 120px; 
            display: flex;
            justify-content: space-between;
            align-items: stretch; /* Stretch buttons to fill height */
            gap: 20px;
            padding: 10px 20px;
            /* Extra padding for iPhone Home Bar */
            padding-bottom: env(safe-area-inset-bottom, 20px); 
            box-sizing: content-box; /* Ensures padding adds to height */
            flex-shrink: 0;
            z-index: 100;
        }

        /* DESKTOP MODE: Hide controls on screens wider than 1024px */
        @media (min-width: 1024px) {
            .controls-area {
                display: none !important;
            }
        }

        .control-btn {
            flex: 1; /* Grow to fill width */
            border-radius: 20px; /* Rounded rectangle */
            border: 2px solid;
            font-size: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.1s;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .control-btn:active { transform: scale(0.98); background: rgba(255,255,255,0.3); }

        /* --- OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            display: none; 
            padding: 20px;
            text-align: center;
        }
        .overlay.active { display: flex; }

        .overlay h2 {
            font-size: 3rem;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            font-style: italic;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            border: none;
            color: #000;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
            transition: transform 0.1s;
            margin-top: 10px;
        }
        .start-btn:active { transform: scale(0.95); }

        /* --- MODE SELECTOR --- */
        .mode-container {
            margin-bottom: 20px;
            width: 100%;
            max-width: 320px;
        }

        .mode-selector {
            display: flex;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 4px;
            gap: 4px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px 5px;
            background: transparent;
            border: none;
            color: #aaa;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            text-transform: uppercase;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .mode-btn.active {
            background: #fff;
            color: #000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .mode-desc {
            margin-top: 15px;
            font-size: 0.9rem;
            color: rgba(255,255,255,0.8);
            font-style: italic;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- THEMES --- */
        body.theme-neon { background-color: #240a1e; color: #ff66ff; }
        .theme-neon .canvas-wrapper { background: linear-gradient(135deg, #ff00cc, #9900ff); }
        .theme-neon canvas { 
            background-image: linear-gradient(#2a0a2e 1px, transparent 1px), linear-gradient(90deg, #2a0a2e 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .theme-neon .start-btn { background: #ff00cc; color: #fff; box-shadow: 0 0 20px #ff00cc; }
        .theme-neon .control-btn { border-color: #ff00cc; color: #ff00cc; }

        body.theme-retro { background-color: #333; color: #fff; font-family: 'Courier New', monospace; }
        .theme-retro .game-header { background: #000; border-color: #fff; }
        .theme-retro .canvas-wrapper { background: #fff; padding: 2px; box-shadow: none; border-radius: 0; }
        .theme-retro canvas { background: #000; border-radius: 0; background-image: none; }
        .theme-retro .game-title { color: #fff; text-shadow: none; }
        .theme-retro .start-btn { background: #fff; color: #000; clip-path: none; border-radius: 0; box-shadow: none; }
        .theme-retro .control-btn { border: 2px solid #fff; color: #fff; border-radius: 0; background: #000; }
        .theme-retro .mode-btn.active { background: #fff; color: #000; }

        body.theme-chameleon { background-color: #0a1e24; color: #00ffcc; }
        .theme-chameleon .canvas-wrapper { background: linear-gradient(135deg, #00ffcc, #00ff66); }
        .theme-chameleon canvas { 
            background-image: linear-gradient(#022e2a 1px, transparent 1px), linear-gradient(90deg, #022e2a 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .theme-chameleon .start-btn { background: #00ffcc; color: #000; box-shadow: 0 0 20px #00ffcc; }
        .theme-chameleon .control-btn { border-color: #00ffcc; color: #00ffcc; }
        .theme-chameleon .game-title { color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }

        /* --- CONTROL MODES --- */
        body.control-swipe .controls-area { display: none !important; }

    </style>
    <link rel="manifest" href="manifest.json">
</head>
<body class="theme-neon">

    <header class="game-header">
        <a href="../../index.html" class="back-btn">‚Üê Arcade</a>
        <div class="title-group">
            <h1 class="game-title">Neon Serpent</h1>
            <div style="display:flex; align-items:center; justify-content:flex-end; gap:15px;">
                <button id="switchEngineBtn" onclick="location.href='negen_version/index.html'" style="background:rgba(255,255,255,0.1); border:1px solid currentColor; color:inherit; font-size:0.7rem; padding:4px 8px; border-radius:4px; cursor:pointer; text-transform:uppercase;">Play Remastered</button>
                <button id="muteBtn" style="background:none; border:none; color:inherit; font-size:1.2rem; cursor:pointer; opacity:1;">üîä</button>
                <div class="score-display">SCORE: <span id="score">0</span></div>
            </div>
        </div>
    </header>

    <div class="game-stage">
        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            
            <div id="gameOverScreen" class="overlay">
                <h2>CRASHED</h2>
                <div style="margin-bottom: 20px; font-size: 1.2rem; color: inherit;">Score: <span id="finalScore">0</span></div>
                <button id="retryBtn" class="start-btn">RETRY</button>
            </div>

            <div id="startScreen" class="overlay active" style="background: rgba(0,0,0,0.6);">
                <div style="margin-bottom:10px; font-weight:bold; letter-spacing:1px; color:inherit; opacity:0.8;">THEME</div>
                
                <div class="mode-container">
                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="setMode('neon')">Neon</button>
                        <button class="mode-btn" onclick="setMode('chameleon')">Color Eater</button>
                        <button class="mode-btn" onclick="setMode('retro')">B&W</button>
                    </div>
                    <div id="modeDesc" class="mode-desc">
                        Classic arcade action with a cyber glow.
                    </div>
                </div>

                <div style="margin-bottom:10px; font-weight:bold; letter-spacing:1px; color:inherit; opacity:0.8;">CONTROLS</div>
                <div class="mode-container" style="margin-bottom: 30px;">
                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="setControlMode('buttons')">Buttons</button>
                        <button class="mode-btn" onclick="setControlMode('swipe')">Swipe</button>
                    </div>
                </div>

                <button id="startBtn" class="start-btn">PLAY</button>
                <button id="settingsBtn" class="mode-btn" style="margin-top:20px; width:auto; padding:10px 20px; background:rgba(255,255,255,0.2);">‚öôÔ∏è SETTINGS</button>
            </div>

            <div id="settingsOverlay" class="overlay">
                <h2>SETTINGS</h2>

                <div style="margin-bottom:10px; font-weight:bold; letter-spacing:1px; color:inherit; opacity:0.8;">GRID SIZE</div>
                <div class="mode-container">
                    <div class="mode-selector">
                        <button class="mode-btn" onclick="setGridSize(15)">Small</button>
                        <button class="mode-btn active" onclick="setGridSize(20)">Normal</button>
                        <button class="mode-btn" onclick="setGridSize(25)">Large</button>
                    </div>
                </div>

                <button id="closeSettingsBtn" class="start-btn">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- TOUCH ZONES (Invisible overlays for half-screen tapping) -->
    <div id="touchZones" style="position:fixed; top:60px; left:0; width:100%; bottom:0; z-index:5; display:flex; pointer-events:none;">
        <div id="zoneLeft" style="flex:1;"></div>
        <div id="zoneRight" style="flex:1;"></div>
    </div>

    <div class="controls-area">
        <button class="control-btn" id="btnLeft">‚Ü∂</button>
        <button class="control-btn" id="btnRight">‚Ü∑</button>
    </div>

    <footer style="width:100%; text-align:center; padding:5px; font-size:0.7rem; opacity:0.5; position:absolute; bottom:0; pointer-events:none;">
        Updates by Jules (v2.0) - Jan 2026
    </footer>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startScreen = document.getElementById('startScreen');
        const modeDesc = document.getElementById('modeDesc');
        const controlsArea = document.querySelector('.controls-area');
        const body = document.body;

        let snake, direction, food, score, gameLoop, isGameOver;
        let isAttractMode = false; 
        let pendingDirection;
        let currentMode = 'neon'; 
        let currentControlMode = 'buttons';
        let activeColor = '#ffffff';
        let tileCount = 20;

        // --- LOCAL STORAGE ---
        function loadSettings() {
            const storedTheme = localStorage.getItem('snake_theme');
            const storedControl = localStorage.getItem('snake_controlMode');
            const storedGrid = localStorage.getItem('snake_gridSize');
            const storedMute = localStorage.getItem('snake_muted');

            if(storedTheme) setMode(storedTheme);
            if(storedControl) setControlMode(storedControl);
            if(storedGrid) setGridSize(parseInt(storedGrid));
            if(storedMute === 'true') {
                 SoundManager.muted = true;
                 const muteBtn = document.getElementById('muteBtn');
                 muteBtn.textContent = 'üîá';
                 muteBtn.style.opacity = '0.5';
            }
        }

        function saveSettings() {
            localStorage.setItem('snake_theme', currentMode);
            localStorage.setItem('snake_controlMode', currentControlMode);
            localStorage.setItem('snake_gridSize', tileCount);
            localStorage.setItem('snake_muted', SoundManager.muted);
        }

        const SoundManager = {
            ctx: null,
            muted: false,

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            toggleMute() {
                this.muted = !this.muted;
                return this.muted;
            },

            playTone(freq, type, duration, slideTo = null) {
                if (this.muted) return;
                try {
                    if (!this.ctx) this.init();

                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    if (slideTo) {
                        osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                    }

                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.ctx.destination);

                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                } catch(e) { console.error(e); }
            },

            playEat() {
                this.playTone(600, 'sine', 0.1, 800);
            },

            playCrash() {
                this.playTone(150, 'sawtooth', 0.4, 50);
            }
        };

        const SoundManager = {
            ctx: null,
            muted: false,

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            toggleMute() {
                this.muted = !this.muted;
                return this.muted;
            },

            playTone(freq, type, duration, slideTo = null) {
                if (this.muted) return;
                try {
                    if (!this.ctx) this.init();

                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    if (slideTo) {
                        osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                    }

                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.ctx.destination);

                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                } catch(e) { console.error(e); }
            },

            playEat() {
                this.playTone(600, 'sine', 0.1, 800);
            },

            playCrash() {
                this.playTone(150, 'sawtooth', 0.4, 50);
            }
        };

        const SoundManager = {
            ctx: null,
            muted: false,

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            toggleMute() {
                this.muted = !this.muted;
                return this.muted;
            },

            playTone(freq, type, duration, slideTo = null) {
                if (this.muted) return;
                try {
                    if (!this.ctx) this.init();

                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    if (slideTo) {
                        osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                    }

                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.ctx.destination);

                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                } catch(e) { console.error(e); }
            },

            playEat() {
                this.playTone(600, 'sine', 0.1, 800);
            },

            playCrash() {
                this.playTone(150, 'sawtooth', 0.4, 50);
            }
        };

        const PALETTE = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800'];
        let gridSize; 
        
        const DESCRIPTIONS = {
            neon: "Classic arcade action with a cyber glow.",
            chameleon: "You are what you eat! Change colors instantly.",
            retro: "Old school purity. No effects, just skill."
        };

        function resize() {
            // Logic Check: Are buttons hidden?
            const controlsHidden = getComputedStyle(controlsArea).display === 'none';
            
            // Calculate height buffers
            const headerHeight = 60;
            // IMPORTANT: Increased buffer from 120 -> 160 to account for Safe Area Inset padding
            const controlsHeight = controlsHidden ? 0 : 160; 
            const padding = 20;

            const availableHeight = window.innerHeight - (headerHeight + controlsHeight + padding);
            const availableWidth = window.innerWidth - 40;
            
            // Max size limit
            const maxSize = controlsHidden ? 600 : 400;

            let size = Math.min(availableWidth, availableHeight, maxSize);
            
            // Fix Grid Alignment: Ensure size is perfectly divisible by tileCount
            gridSize = Math.floor(size / tileCount);
            size = gridSize * tileCount;

            canvas.width = size;
            canvas.height = size;

            if(snake) draw(); 
        }
        window.addEventListener('resize', resize);
        resize(); 

        window.setControlMode = function(mode) {
            currentControlMode = mode;
            if (mode === 'swipe') {
                body.classList.add('control-swipe');
            } else {
                body.classList.remove('control-swipe');
            }

            const btns = document.querySelectorAll('[onclick^="setControlMode"]');
            btns.forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === mode);
            });

            // Toggle Touch Zones based on mode
            const touchZones = document.getElementById('touchZones');
            if (mode === 'buttons') {
                 touchZones.style.display = 'flex';
                 // We need pointer events on children when active
                 document.getElementById('zoneLeft').style.pointerEvents = 'auto';
                 document.getElementById('zoneRight').style.pointerEvents = 'auto';
            } else {
                 touchZones.style.display = 'none';
                 document.getElementById('zoneLeft').style.pointerEvents = 'none';
                 document.getElementById('zoneRight').style.pointerEvents = 'none';
            }

            saveSettings();
            resize();
        }
      
        window.setGridSize = function(size) {
            tileCount = size;
            const btns = document.querySelectorAll('[onclick^="setGridSize"]');
            btns.forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(size === 15 ? 'small' : size === 20 ? 'normal' : 'large'));
            });
            saveSettings();
            resize();
            if(isAttractMode) startAttractMode();
        }

        window.setMode = function(mode) {
            currentMode = mode;
            body.className = `theme-${mode}`;
            modeDesc.textContent = DESCRIPTIONS[mode];

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if(mode === 'neon' && btn.textContent === 'Neon') btn.classList.add('active');
                if(mode === 'chameleon' && btn.textContent === 'Color Eater') btn.classList.add('active');
                if(mode === 'retro' && btn.textContent === 'B&W') btn.classList.add('active');
            });

            saveSettings();

            const title = document.querySelector('.game-title');
            if(mode === 'neon') title.textContent = "Neon Serpent";
            if(mode === 'retro') title.textContent = "Snake_V1.0";
            if(mode === 'chameleon') title.textContent = "Color Eater";
            
            startAttractMode();
        }

        function resetState() {
            const startColor = currentMode === 'chameleon' ? '#ffffff' : null;
            snake = [
                { x: 10, y: 15, color: startColor },
                { x: 10, y: 16, color: startColor },
                { x: 10, y: 17, color: startColor }
            ];
            direction = { x: 0, y: -1 }; 
            pendingDirection = { x: 0, y: -1 };
            activeColor = '#ffffff';
            food = randomFood(); 
            score = 0;
            scoreEl.textContent = 0;
            isGameOver = false;
        }

        function calculateSpeed() {
            if (isAttractMode) return 80;
            return Math.max(50, 110 - (score * 2));
        }

        function initGame() {
            SoundManager.init();
            isAttractMode = false; 
            resetState();
            gameOverScreen.classList.remove('active');
            startScreen.classList.remove('active');

            if (currentControlMode === 'buttons') {
                document.getElementById('touchZones').style.display = 'flex';
                document.getElementById('touchZones').style.zIndex = '15';
            }

            if (gameLoop) clearTimeout(gameLoop);
            gameTick();
        }

        function startAttractMode() {
            isAttractMode = true;
            resetState();

            // Disable touch zones behind overlay
            document.getElementById('touchZones').style.display = 'none';

            if (gameLoop) clearTimeout(gameLoop);
            gameTick();
        }

        function randomFood() {
            let newFood;
            while (true) {
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    color: PALETTE[Math.floor(Math.random() * PALETTE.length)]
                };
                if (!snake.some(seg => seg.x === newFood.x && seg.y === newFood.y)) {
                    return newFood;
                }
            }
        }

        function getBotMove() {
            const head = snake[0];
            const moves = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }
            ];
            const validMoves = moves.filter(m => {
                const nx = head.x + m.x;
                const ny = head.y + m.y;
                if (nx < 0 || nx >= tileCount || ny < 0 || ny >= tileCount) return false;
                if (snake.some(s => s.x === nx && s.y === ny)) return false;
                if (m.x === -direction.x && m.y === -direction.y) return false;
                return true;
            });
            if (validMoves.length === 0) return direction; 
            validMoves.sort((a, b) => {
                const distA = Math.abs((head.x + a.x) - food.x) + Math.abs((head.y + a.y) - food.y);
                const distB = Math.abs((head.x + b.x) - food.x) + Math.abs((head.y + b.y) - food.y);
                return distA - distB;
            });
            return validMoves[0];
        }

        function gameTick() {
            if (isAttractMode) {
                direction = getBotMove();
            } else {
                direction = pendingDirection;
            }

            const head = { 
                x: snake[0].x + direction.x, 
                y: snake[0].y + direction.y,
                color: activeColor 
            };

            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount || 
                snake.some(seg => seg.x === head.x && seg.y === head.y)) {
                if (isAttractMode) {
                    startAttractMode(); 
                    return;
                } else {
                    return endGame();
                }
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                if (!isAttractMode) {
                    SoundManager.playEat();
                    score++;
                    scoreEl.textContent = score;
                    if(navigator.vibrate) navigator.vibrate(50);
                }
                if (currentMode === 'chameleon') {
                    activeColor = food.color;
                    snake[0].color = activeColor; 
                }
                food = randomFood();
            } else {
                snake.pop();
            }

            draw();
            if (!isGameOver) {
                gameLoop = setTimeout(gameTick, calculateSpeed());
            }
        }

        function draw() {
            if(!snake) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            snake.forEach((seg, i) => {
                let fill, blur, shadowColor;
                if (currentMode === 'retro') {
                    fill = '#ffffff'; blur = 0;
                } else if (currentMode === 'chameleon') {
                    fill = seg.color || '#fff'; blur = 10; shadowColor = fill;
                } else {
                    if (i === 0) {
                        fill = '#ffffff'; blur = 20; shadowColor = "#ff00cc";
                    } else {
                        const hue = 320 - (i * 4); 
                        fill = `hsl(${hue}, 100%, 50%)`;
                        blur = 10; shadowColor = fill;
                    }
                }
                ctx.fillStyle = fill;
                if(currentMode !== 'retro') {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = shadowColor;
                }
                ctx.fillRect(seg.x * gridSize + 1, seg.y * gridSize + 1, gridSize - 2, gridSize - 2);
            });

            ctx.shadowBlur = 0;
            let foodFill;
            if (currentMode === 'retro') {
                foodFill = '#ffffff';
            } else if (currentMode === 'chameleon') {
                foodFill = food ? food.color : '#fff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = foodFill;
            } else {
                foodFill = '#00ffff'; 
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#00ffff";
            }
            ctx.fillStyle = foodFill;
            if (currentMode === 'retro') {
                if(food) ctx.fillRect(food.x * gridSize + 4, food.y * gridSize + 4, gridSize - 8, gridSize - 8);
            } else {
                ctx.beginPath();
                const cx = food ? food.x * gridSize + gridSize/2 : 0;
                const cy = food ? food.y * gridSize + gridSize/2 : 0;
                ctx.arc(cx, cy, gridSize/2 - 4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        }

        function endGame() {
            clearTimeout(gameLoop);
            isGameOver = true;
            SoundManager.playCrash();
            if(navigator.vibrate) navigator.vibrate(300);
            finalScoreEl.textContent = score;
            gameOverScreen.classList.add('active');
        }

        function turnLeft() {
            if (isGameOver || isAttractMode) return;
            const newDir = { x: direction.y, y: -direction.x };
            pendingDirection = newDir;
        }

        function turnRight() {
            if (isGameOver || isAttractMode) return;
            const newDir = { x: -direction.y, y: direction.x };
            pendingDirection = newDir;
        }

        function setDirection(x, y) {
             if (x === -pendingDirection.x && y === -pendingDirection.y) return;
             pendingDirection = { x, y };
        }

        // Swipe Logic
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.addEventListener('touchmove', e => {
            if (currentControlMode === 'swipe' && !isAttractMode && !isGameOver) {
                 e.preventDefault();
            }
        }, {passive: false});

        document.addEventListener('touchend', e => {
            if (currentControlMode !== 'swipe' || isAttractMode || isGameOver) return;

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) setDirection(1, 0);
                else setDirection(-1, 0);
            } else {
                if (dy > 0) setDirection(0, 1);
                else setDirection(0, -1);
            }
        }, {passive: false});

        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        const zoneLeft = document.getElementById('zoneLeft');
        const zoneRight = document.getElementById('zoneRight');

        function handleInput(dir) {
             if (dir === 'left') turnLeft();
             if (dir === 'right') turnRight();
        }

        // Zone Inputs (Half Screen)
        zoneLeft.addEventListener('touchstart', (e) => { if(currentControlMode === 'buttons') { e.preventDefault(); handleInput('left'); } });
        zoneRight.addEventListener('touchstart', (e) => { if(currentControlMode === 'buttons') { e.preventDefault(); handleInput('right'); } });
        zoneLeft.addEventListener('mousedown', () => { if(currentControlMode === 'buttons') handleInput('left'); });
        zoneRight.addEventListener('mousedown', () => { if(currentControlMode === 'buttons') handleInput('right'); });

        // Button Inputs (Visual Feedback)
        btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('left'); });
        btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('right'); });
        btnLeft.addEventListener('mousedown', () => handleInput('left'));
        btnRight.addEventListener('mousedown', () => handleInput('right'));

        document.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft') turnLeft();
            if(e.key === 'ArrowRight') turnRight();
        });

        document.getElementById('startBtn').addEventListener('click', initGame);

        // Settings UI
        const settingsOverlay = document.getElementById('settingsOverlay');
        document.getElementById('settingsBtn').addEventListener('click', () => {
             settingsOverlay.classList.add('active');
             startScreen.classList.remove('active');
        });
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
             settingsOverlay.classList.remove('active');
             startScreen.classList.add('active');
        });

        document.getElementById('retryBtn').addEventListener('click', () => {
            gameOverScreen.classList.remove('active');
            startScreen.classList.add('active');
            startAttractMode(); 
        });

        const muteBtn = document.getElementById('muteBtn');
        muteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isMuted = SoundManager.toggleMute();
            muteBtn.textContent = isMuted ? 'üîá' : 'üîä';
            muteBtn.style.opacity = isMuted ? '0.5' : '1';
            saveSettings();
        });

        // Initialize
        loadSettings();
        startAttractMode();

    </script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    }, err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>

</body>
</html>