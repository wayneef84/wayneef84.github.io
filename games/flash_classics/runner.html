<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Runner - Flash Classics</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="start-screen" class="overlay">
        <h1>NEON RUNNER</h1>
        <p class="controls-hint">Tap/Click/Space to Jump<br>Avoid gaps and red spikes.</p>
        <a href="#" class="flash-btn" id="start-btn">PLAY</a>
        <a href="index.html" style="color: #888; margin-top: 20px; text-decoration: none;">Back to Menu</a>
    </div>

    <div id="gameover-screen" class="overlay hidden">
        <h1>GAME OVER</h1>
        <p id="final-score" style="font-size: 24px; color: #fff; margin-bottom: 20px;">Score: 0</p>
        <a href="#" class="flash-btn" id="restart-btn">TRY AGAIN</a>
        <a href="index.html" style="color: #888; margin-top: 20px; text-decoration: none;">Back to Menu</a>
    </div>

    <div id="score-display" class="score-display hidden">0m</div>
</div>

<script src="js/common.js"></script>
<script>
(function() {
    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');
    var startScreen = document.getElementById('start-screen');
    var gameoverScreen = document.getElementById('gameover-screen');
    var scoreDisplay = document.getElementById('score-display');
    var finalScoreText = document.getElementById('final-score');
    var startBtn = document.getElementById('start-btn');
    var restartBtn = document.getElementById('restart-btn');

    var state = GameState.MENU;
    var score = 0;
    var frameId = 0;

    var player = {
        x: 100,
        y: 0,
        width: 30,
        height: 30,
        vy: 0,
        gravity: 0.8,
        jumpForce: -15,
        grounded: false,
        color: '#00ffff'
    };

    var platforms = [];
    var spikes = [];
    var speed = 8;
    var platformWidth = 80;

    // Grid animation
    var gridOffset = 0;

    function resetGame() {
        score = 0;
        speed = 8;
        player.y = 300;
        player.vy = 0;
        player.grounded = false;
        platforms = [];
        spikes = [];

        // Initial ground
        platforms.push({
            x: 0,
            y: 400,
            width: 1000,
            height: 200
        });
    }

    function generateLevel() {
        var lastPlat = platforms[platforms.length - 1];

        // Only generate if we need more
        if (lastPlat.x + lastPlat.width < canvas.width + 200) {
            var gap = Utils.randomInt(100, 200);
            var yChange = Utils.randomInt(-100, 100);
            var newY = Math.max(200, Math.min(500, lastPlat.y + yChange));
            var newWidth = Utils.randomInt(200, 600);

            var newPlat = {
                x: lastPlat.x + lastPlat.width + gap,
                y: newY,
                width: newWidth,
                height: 600 - newY
            };

            platforms.push(newPlat);

            // Add Spike?
            if (newWidth > 300 && Math.random() > 0.5) {
                spikes.push({
                    x: newPlat.x + Utils.randomInt(100, newWidth - 50),
                    y: newPlat.y - 20,
                    width: 20,
                    height: 20
                });
            }
        }
    }

    function update() {
        if (state !== GameState.PLAYING) return;

        // Player Physics
        player.vy += player.gravity;
        player.y += player.vy;

        player.grounded = false;

        // Move World
        for (var i = 0; i < platforms.length; i++) {
            platforms[i].x -= speed;
        }
        for (var i = 0; i < spikes.length; i++) {
            spikes[i].x -= speed;
        }

        gridOffset = (gridOffset - speed/2) % 40;

        // Cleanup
        if (platforms[0].x + platforms[0].width < -100) platforms.shift();
        if (spikes.length > 0 && spikes[0].x < -100) spikes.shift();

        // Generation
        generateLevel();

        // Collision: Platforms
        // Check if player lands on top
        for (var i = 0; i < platforms.length; i++) {
            var p = platforms[i];

            // AABB Check
            if (player.x < p.x + p.width &&
                player.x + player.width > p.x &&
                player.y < p.y + p.height &&
                player.y + player.height > p.y) {

                // Collision happened.
                // Was it from top?
                // Previous Y was (player.y - player.vy)
                var prevY = player.y - player.vy;
                if (prevY + player.height <= p.y + 10) { // Tolerance
                    player.grounded = true;
                    player.vy = 0;
                    player.y = p.y - player.height;
                } else {
                    // Hit side or bottom = Death
                    gameOver();
                    return;
                }
            }
        }

        // Collision: Spikes
        for (var i = 0; i < spikes.length; i++) {
            var s = spikes[i];
            // Simple triangle hit check or box
            if (Utils.checkCollision(player, s)) {
                gameOver();
                return;
            }
        }

        // Fall off screen
        if (player.y > canvas.height) {
            gameOver();
            return;
        }

        score++;
        scoreDisplay.textContent = Math.floor(score / 10) + "m";

        // Speed up
        if (score % 500 === 0) speed += 0.5;
    }

    function draw() {
        // Background Grid
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Grid
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;

        // Vertical
        for (var x = gridOffset; x < canvas.width; x += 40) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        // Horizontal
        for (var y = 0; y < canvas.height; y += 40) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        if (state === GameState.MENU) return;

        // Platforms
        ctx.fillStyle = '#0033cc';
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;

        for (var i = 0; i < platforms.length; i++) {
            var p = platforms[i];
            ctx.fillRect(p.x, p.y, p.width, p.height);
            ctx.strokeRect(p.x, p.y, p.width, p.height);
        }

        // Spikes
        ctx.fillStyle = '#ff0000';
        for (var i = 0; i < spikes.length; i++) {
            var s = spikes[i];
            ctx.beginPath();
            ctx.moveTo(s.x, s.y + s.height);
            ctx.lineTo(s.x + s.width/2, s.y);
            ctx.lineTo(s.x + s.width, s.y + s.height);
            ctx.fill();
        }

        // Player
        ctx.fillStyle = player.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = player.color;
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.shadowBlur = 0;
    }

    function loop() {
        update();
        draw();
        frameId = requestAnimationFrame(loop);
    }

    function jump() {
        if (player.grounded) {
            player.vy = player.jumpForce;
            player.grounded = false;
        }
    }

    function startGame() {
        state = GameState.PLAYING;
        startScreen.classList.add('hidden');
        gameoverScreen.classList.add('hidden');
        scoreDisplay.classList.remove('hidden');
        resetGame();
    }

    function gameOver() {
        state = GameState.GAMEOVER;
        gameoverScreen.classList.remove('hidden');
        scoreDisplay.classList.add('hidden');
        finalScoreText.textContent = "Distance: " + Math.floor(score/10) + "m";
    }

    // Input
    document.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            if (state === GameState.MENU || state === GameState.GAMEOVER) {
                startGame();
            } else {
                jump();
            }
        }
    });

    canvas.addEventListener('mousedown', function(e) {
        e.preventDefault();
        if (state === GameState.PLAYING) jump();
    });

    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (state === GameState.PLAYING) jump();
    }, {passive: false});

    // Start Buttons
    startBtn.addEventListener('click', function(e) { e.preventDefault(); startGame(); });
    startBtn.addEventListener('touchend', function(e) { e.preventDefault(); startGame(); });
    restartBtn.addEventListener('click', function(e) { e.preventDefault(); startGame(); });
    restartBtn.addEventListener('touchend', function(e) { e.preventDefault(); startGame(); });

    // Initial render
    resetGame();
    loop();

})();
</script>
</body>
</html>
