Here is the comprehensive plan and technical specification for the Card Engine Rebuild and Testing Suite, transformed into plain text.

1. The Core Project Specification

This document outlines the architectural requirements for the Pro/C models to follow.

ARCADE CARD SYSTEM SPECIFICATION v2.0

1. PROJECT PHILOSOPHY
Create a game-agnostic State Machine Engine that delegates logic to interchangeable Ruleset modules. All UI must be mobile-first and optimized for touch interactions.
2. ENGINE LOGIC (engine.js)
The Engine acts as the Dealer. It manages the flow but doesn't know the rules.
The Post-Action Hook: After EVERY card dealt or action taken, the engine must call ruleset.checkWinCondition(gameState).
Immediate Termination: If checkWinCondition returns {immediate: true}, the Engine MUST skip all remaining turns (including Dealer turn) and transition directly to the RESOLUTION state.
Turn Traffic Control: Use ruleset.getNextActor(gameState) to determine the next player. If it returns null, the round is over.
3. BLACKJACK RULESET (blackjack.js)
Double Down: Deduct 1x bet, deal exactly 1 card, force Stand. Only available on the player's first move.
Dealer Behavior: Standard logic (Hit on 16, Stand on 17).
Bust Suppression: If the human player busts, getNextActor MUST return null immediately to prevent the Dealer from drawing cards.
4. MOBILE UI ARCHITECTURE (index.html)
Fixed Footer: Use position: fixed; bottom: 0; for the control bar to prevent layout shifts.
Scrollable Table: The card area must have overflow-y: auto; to handle multi-card hands on small screens.
Dealer Layout (Top-Down): Label -> Cards -> Value Bubble.
Player Layout (Bottom-Up): Cards -> Value Bubble -> Label.
Bubble Logic: Hide Value Bubbles if the value is 0 or no cards are present.
Chip Set: - $1, $5, $25, $50, $100 (Gold/Black style).
Clear Bet: Red X chip.
Buttons: Deal Hand and New Hand must be full-width (approx 400px max) for thumb access.
5. REUSABLE RULESET VARIANTS
Rulesets should accept a config object to allow multiple versions of the same game:
Variant A: Standard 3D start.
Variant B: Dealer-clockwise tie-break.
6. Universal Test Suite Specification (test.html)

This document describes the testing module to verify that your rules actually work.

TEST SUITE SPECIFICATION (test.html)

1. OBJECTIVE
A headless runner that imports any ruleset.js and verifies its logic against predefined PASS/FAIL scenarios.
2. TEST CASE STRUCTURE
Every test must define:
Setup: A specific hand/piles configuration.
Action: A specific function call (e.g., hit, stand, deal).
Expectation: The expected state or multiplier returned.
3. PREDEFINED TEST SETS
BLACKJACK TEST SET
BJ-01 (Bust Bypass): Setup: Player(15), Dealer(10). Action: Hit 10. Expectation: getNextActor returns null, resolveRound returns lose.
BJ-02 (Double Down): Setup: Player(11). Action: Double. Expectation: Pot increases, 1 card added, getNextActor returns dealer.

WAR TEST SET
WAR-01 (High Card): Setup: Player(Ace), Dealer(King). Action: Resolve. Expectation: Player result = win.
WAR-02 (Initiate War): Setup: Player(10), Dealer(10). Action: Resolve. Expectation: Game State = WAR_DEALING.
WAR-03 (Nested War): Setup: Tie on second War card. Action: Resolve. Expectation: State remains WAR_DEALING for secondary tie-break.

BIG 2 (LOGIC TEST)
B2-01 (Starting Player): Setup: Decks contain 3D, 4D. Expectation: Player with 3D is returned by getNextActor.
B2-02 (Tie-Break): Setup: Multiple decks, two players have 3D. Expectation: Tie-break logic selects next lowest or clockwise from dealer.

3. In-Game Debug Module Specification

This allows you to trigger specific game glitches or wins manually for quick visual testing.

DEBUG OVERLAY SPECIFICATION

1. UI TRIGGER
A hidden button or triple-tap gesture on the header to reveal the Dev Console.
2. COMMAND LIST
FORCE_PLAYER_BJ: Replaces player hand with (Ace, King) and resolves.
FORCE_PLAYER_BUST: Forces next card in deck to be a 10 and triggers a player Hit.
FORCE_DEALER_BUST: Forces Dealer to draw cards until score > 21.
FORCE_TIE: Matches dealer score to player score.
RESET_BANK: Sets localStorage balance back to $1000.

I have completed the transformation into plaintext. Would you like me to proceed with the Big 2 Config Object layout?

--- Schematics ---
Item 1: State Machine Diagram Specification

This is the logical blueprint for the Pro model to solve the game flow issues.

Flow Logic:

Idle State: The game is waiting for the player.

Betting State: The player selects chips. The engine waits for confirmation before moving to the deal.

Dealing State: The engine uses the ruleset to distribute cards.

Terminal Check Gate: This happens after every single card. The engine calls the ruleset to see if the round should end immediately.

If the player is over 21 or has a blackjack, the engine jumps to the Resolution state. This prevents the dealer from taking a turn.

If the game is still active, the engine moves to the Player Turn.

Player Turn: The player can Hit, Stand, or Double.

If the player Hits or Doubles, the engine returns to the Terminal Check Gate.

If the player Stands, the engine moves to the Dealer Turn.

Dealer Turn: This only happens if the player did not bust. The dealer draws cards based on the ruleset threshold.

Resolution State: This is the end of the round. The engine calculates the win or loss, updates the balance, and shows the reset button.

Key Logic Requirements:

Dealer Turn Bypass: If the Terminal Check Gate finds a player bust, the dealer turn must be skipped entirely.

Hang Prevention: If getNextActor returns null, the engine must immediately transition to the Resolution state.

Double Down: This action must be available on the first turn. It adds one card and then forces the state to Stand.


--- Test case for war ---
Task 2: War Test Cases

These test cases will be used in the test.html file to ensure the War ruleset logic handles standard play and the specific War tie-break sequences correctly.

1. Standard Round Win

* Setup: Player is dealt an Ace of Spades. Dealer is dealt a King of Hearts.
* Action: Call the ruleset resolution function.
* Expected Result: The player is declared the winner of the round. The payout or card collection logic should attribute both cards to the player.

2. War Initiation (Tie)

* Setup: Player is dealt a Jack of Diamonds. Dealer is dealt a Jack of Clubs.
* Action: Call the ruleset getNextActor or checkWinCondition function.
* Expected Result: The game state transitions to War. The engine should recognize that neither player has won yet and require additional cards to be dealt.

3. The War Sequence

* Setup: A tie has occurred. Three face-down cards are dealt for each player, followed by one face-up card.
* Action: Compare the two new face-up cards.
* Expected Result: The player with the higher face-up card wins all cards currently on the table (the original tie, the face-down cards, and the final face-up cards).

4. Double War (Tie during War)

* Setup: During the War sequence, the second set of face-up cards also tie.
* Action: Call the resolution logic.
* Expected Result: The game must not end. It should trigger a secondary War sequence, dealing another set of face-down and face-up cards until a winner is determined.

5. Insufficient Cards for War

* Setup: A tie occurs, but the shoe or the player's deck does not have enough cards to complete the three-card face-down requirement.
* Action: Check ruleset fallback logic.
* Expected Result: The ruleset should either use the final available card as the tie-breaker or declare a draw based on your specific house rules.

I have finished Task 2. Shall I move to Task 3: The plan for the ruleset testing?

--- task 3 - war test ---
Task 3: Ruleset Testing Plan

This plan describes how the test.html file will function as a diagnostic tool for your arcade. It allows you to verify that every game follows its rules perfectly before you play it.

1. Test Environment Structure
The testing tool will be a standalone web page that imports the shared engine files and the specific ruleset being tested. It will not require the full game UI to run, focusing purely on data and logic.
2. Component Selection
The user interface for the test page will include:

* A dropdown menu to select which ruleset to load (Blackjack, War, or Big 2).
* A list of available test categories for that specific game.
* A Run All button to execute every test in the sequence.

3. Execution Logic
For each test case, the system will perform the following steps:

* Mock State: The test runner creates a fake game state with specific cards assigned to the player and dealer.
* Action Trigger: The runner executes a specific function, such as resolveAction or getNextActor.
* Validation: The runner compares the actual result against the expected result defined in the test case.

4. Results Reporting
The page will display a live feed of the tests being conducted:

* A green checkmark or the word PASS if the result matches the expectation.
* A red X or the word FAIL if the result is different, along with a description of what went wrong (for example, Expected state Resolution but got Player Turn).

5. Specific Logic Targets
The testing plan focuses on these high-risk areas:

* Payout Accuracy: Ensuring the multiplier for a Blackjack or a standard win is calculated correctly.
* State Transitions: Verifying that the game moves to the correct next phase after an action.
* Edge Cases: Testing what happens when a deck runs out of cards or a player has exactly zero balance.

I have finished Task 3. Shall I move to Task 4: Big 2 config object layout?

--- task 4 big 2 config layout ---
Task 4: Big 2 Config Object Layout

The Big 2 ruleset requires a more complex configuration than Blackjack or War because house rules vary significantly. The config object allows the engine to adapt to these variations without changing the core game code.

1. Starting Player Logic

* firstMoveCriteria: This defines which card starts the game.
* Options: 3_OF_DIAMONDS (Standard), 3_OF_SPADES, or LOWEST_CARD_IN_SHOE.
* tieBreak: If multiple decks are used and two players have the same starting card.
* Options: CLOCKWISE_FROM_DEALER or NEXT_LOWEST_CARD.

2. Card and Suit Ranking

* suitOrder: Defines which suit is strongest.
* Example: SPADES, HEARTS, CLUBS, DIAMONDS (Standard Asian).
* Example: SPADES, HEARTS, DIAMONDS, CLUBS (Western variation).
* twosHigh: A boolean (True/False) to confirm if 2s are the highest value cards.

3. Valid Hand Combinations

* allowStraightFlush: Boolean.
* allowFullHouse: Boolean.
* straightLogic: Defines if specific straights like A-2-3-4-5 or 2-3-4-5-6 are allowed as high or low hands.

4. Game End and Scoring

* scoringType:
* PER_CARD: Penalty based on number of cards left in hand.
* DOUBLE_OVER_TEN: Double the penalty if a player has 10 or more cards.
* TRIPLE_OVER_THIRTEEN: Triple the penalty for a full hand of 13 cards.

5. Sample Config Object Implementation

* gameId: big_two_standard
* startingCard: 3D
* maxPlayers: 4
* deckCount: 1
* reverseRanking: false

This object is passed into the Big 2 Ruleset when the game initializes. The Ruleset then uses these keys to determine who gets the first turn in getNextActor and who wins a hand in evaluateHand.

I have completed all four tasks in plaintext. Is there anything else you would like to refine or move on to?

Based on the comprehensive plan and your uploaded file, here is the updated analysis. This version integrates the refined logic from the ten-round audit and the specific project goals in your **todo_260113.md** file.

### Final Engine and Ruleset Analysis

The architecture establishes a "Gatekeeper" system where the engine (engine.js) manages state flow while the rulesets (blackjack.js, war.js, big2.js) dictate logic and victory conditions. The primary focus is eliminating "hanging" states and unauthorized dealer turns through the **Terminal Check Gate**.

#### 1. Core State Machine Updates

* **Post-Action Hook**: Every card deal or player action triggers a mandatory check. If the ruleset returns an immediate end-state, the engine jumps directly to Resolution, bypassing the Dealer Turn entirely.
* **Bust Suppression**: In Blackjack, if the player busts, the `getNextActor` function must return `null` immediately, killing the dealer's ability to draw cards.
* **Recursive War Loops**: For the War ruleset, the engine is updated to stay in a "WAR_DEALING" state during ties, allowing for nested wars (Double/Triple War) without breaking the flow.

#### 2. Universal Test Suite (test.html) Refinements

The testing tool is designed as a headless runner to verify logic before UI implementation.

* **Mock State Injection**: The runner will manually set hands (e.g., Player has 15, Dealer has 10) to test specific logic gates like "Bust Bypass" (BJ-01) and "Double Down" (BJ-02).
* **Recursive Verification**: Tests for War (WAR-01 through WAR-03) specifically check that the state remains "WAR_DEALING" until a clear winner is found.

#### 3. Big 2 Modularity and Config

Because Big 2 rules vary significantly, the config object now handles all "House Rule" variations:

* **Starting Player**: Configurable via `firstMoveCriteria` (3D, 3S, or Lowest).
* **Scoring Penalties**: Handles multipliers like `DOUBLE_OVER_TEN` or `TRIPLE_OVER_THIRTEEN` within the Resolution state.

---

### Project Changelog & Analysis Updates

| Round | Audit Focus | Resulting Update in Plan |
| --- | --- | --- |
| **1-2** | Flow & Transitions | Defined the **Terminal Check Gate** as the absolute authority to prevent dealer turn-skipping bugs. |
| **3-4** | Rule Isolation | Moved all suit rankings and "Double Down" restrictions (first move only) into ruleset-specific modules. |
| **5** | War Recursion | Standardized the handling of nested ties to ensure the "pot" of cards is maintained during secondary wars. |
| **6-7** | UI & Persistence | Synced "Value Bubbles" to wait for Terminal Check results and required LocalStorage saves after every deal. |
| **8-9** | Multi-Game Scaling | Implemented a mandatory "Engine Reset" and integer-based math to prevent balance errors during complex penalties. |
| **10** | Final Debugging | Integrated manual "Force" commands into the Test Suite to allow instant verification of the Dealer Skip logic. |

---

### Updated To-Do List

1. **Develop `test.html**`: Create the headless runner to load `ruleset.js` files.
2. **Code Blackjack Ruleset**: Implement `checkWinCondition` with the bust-bypass logic.
3. **Build War Test Set**: Verify nested war logic using the headless runner.
4. **Define Big 2 Config**: Finalize the JSON structure for 3D starting rules and suit rankings.
5. **Mobile UI Implementation**: Apply the fixed footer and scrollable table layout in `index.html`.

Would you like me to draft the specific JSON structure for the **Big 2 Config Object** so you can pass it to the Pro model?