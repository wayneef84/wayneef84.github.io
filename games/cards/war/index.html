<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>War - Fong Family Arcade</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100dvh;
        }
        
        .header {
            background: rgba(0,0,0,0.4);
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .header h1 {
            margin: 0;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.2em;
            cursor: pointer;
            padding: 4px 8px;
            transition: color 0.2s;
        }

        .settings-btn:active { color: #ffd700; }
        
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 12px;
            gap: 8px;
            overflow: hidden;
        }
        
        .player-zone {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 10px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-zone.opponent {
            background: rgba(239,68,68,0.1);
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .player-name { font-weight: 600; }

        .score-display {
            display: flex;
            gap: 8px;
        }

        .score-item {
            background: rgba(0,0,0,0.3);
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 0.85em;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }

        .score-item:active {
            background: rgba(255,255,255,0.1);
        }

        .score-item span { color: #fbbf24; font-weight: bold; }
        
        .deck-preview canvas {
            width: 50px;
            height: 70px;
            border-radius: 4px;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
        }
        
        .battle-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 16px;
        }

        .shared-deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .deck-label {
            font-size: 0.85em;
            color: rgba(255,255,255,0.7);
            font-weight: 600;
        }

        .deck-label span {
            color: #fbbf24;
        }
        
        .battle-cards {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
        .battle-card {
            text-align: center;
        }
        
        .battle-card canvas {
            width: 90px;
            height: 126px;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
        }

        .battle-card canvas.slide-in-from-top {
            animation: slideFromTop 0.3s ease-out;
        }

        .battle-card canvas.slide-in-from-bottom {
            animation: slideFromBottom 0.3s ease-out;
        }

        @keyframes slideFromTop {
            from {
                transform: translateY(-200px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideFromBottom {
            from {
                transform: translateY(200px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .battle-card .label {
            font-size: 0.8em;
            color: rgba(255,255,255,0.6);
            margin-top: 6px;
        }
        
        .vs-text {
            font-size: 1.5em;
            font-weight: bold;
            color: #ef4444;
        }
        
        .message {
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            min-height: 40px;
        }
        
        .message.war {
            color: #ef4444;
            text-transform: uppercase;
            animation: pulse 0.5s ease-in-out infinite;
        }
        
        .message.win { color: #4ade80; }
        .message.lose { color: #f87171; }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .war-pot {
            background: rgba(239,68,68,0.2);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .controls {
            background: rgba(0,0,0,0.4);
            padding: 16px;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
            flex-shrink: 0;
        }
        
        .control-row {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        
        .btn {
            padding: 16px 48px;
            font-size: 1.2em;
            font-weight: 700;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.15s ease;
        }
        
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn:not(:disabled):active { transform: scale(0.95); }
        
        .btn-flip {
            background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .btn-new {
            background: linear-gradient(180deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
        }
        
        .hidden { display: none !important; }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #ffd700;
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            margin-top: 0;
            color: #ffd700;
            text-align: center;
            font-size: 1.5em;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 16px 0;
        }

        .setting-row.multi-line {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        .setting-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
        }

        .setting-hint {
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.3;
        }

        .setting-row label {
            font-weight: 600;
            color: #ccc;
        }

        .setting-row input[type="number"] {
            width: 80px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #ffd700;
            background: rgba(0,0,0,0.4);
            color: #fff;
            text-align: center;
        }

        .setting-row input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }

        .full-btn {
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            font-size: 1em;
            font-weight: 700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.15s ease;
        }

        .full-btn:active { transform: scale(0.95); }

        .full-btn.primary-btn {
            background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%);
            color: #000;
        }

        .full-btn.secondary-btn {
            background: linear-gradient(180deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
        }

        .full-btn.close-btn {
            background: linear-gradient(180deg, #6b7280 0%, #4b5563 100%);
            color: white;
        }

        .history-entry {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }

        .history-entry.win { border-left: 4px solid #4ade80; }
        .history-entry.lose { border-left: 4px solid #ef4444; }

        .history-stats {
            background: rgba(255,215,0,0.1);
            padding: 16px;
            border-radius: 12px;
            margin: 16px 0;
            text-align: center;
        }

        .history-stats h3 {
            margin: 0 0 12px 0;
            color: #ffd700;
        }

        .stat-row {
            display: flex;
            justify-content: space-around;
            margin: 8px 0;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.8em;
            color: #aaa;
        }

        /* Auto-Shuffle Flash Modal */
        .auto-shuffle-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .auto-shuffle-flash.show {
            opacity: 1;
        }

        .flash-content {
            background: #1e293b;
            border: 2px solid #4338ca;
            border-radius: 12px;
            padding: 30px 50px;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            text-align: center;
            cursor: pointer;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            border-bottom: 2px solid rgba(255,215,0,0.2);
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border: none;
            border-bottom: 3px solid transparent;
            color: #ccc;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .tab-btn.active {
            border-bottom-color: #ffd700;
            background: rgba(255,215,0,0.1);
            color: #ffd700;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Current Match Tab */
        .current-match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .current-match-header h3 {
            margin: 0;
            color: #ffd700;
            font-size: 1.1em;
        }

        .small-btn {
            padding: 6px 12px;
            font-size: 0.85em;
        }

        .rounds-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .round-entry {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 6px;
            margin: 6px 0;
            font-size: 0.85em;
            border-left: 3px solid #4ade80;
        }

        .round-entry.lose {
            border-left-color: #ef4444;
        }

        .round-entry.war {
            border-left-color: #f59e0b;
            background: rgba(245,158,11,0.1);
        }

        .round-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.9em;
            color: #aaa;
        }

        .round-cards {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 8px 0;
            font-size: 1.1em;
        }

        .card-text {
            font-weight: bold;
            padding: 2px 4px;
        }

        .card-red {
            color: #ef4444;
        }

        .card-black {
            color: #fff;
        }

        .vs {
            color: #888;
            font-size: 0.8em;
        }

        .round-winner {
            text-align: center;
            font-weight: bold;
            color: #4ade80;
            margin-top: 4px;
        }

        .round-winner.lose {
            color: #ef4444;
        }

        .war-sequence {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.4);
            border-radius: 4px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .war-sequence strong {
            color: #f59e0b;
        }

        .no-history {
            text-align: center;
            color: #888;
            padding: 20px;
            font-style: italic;
        }

        .match-entry {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .match-entry:hover {
            background: rgba(255,255,255,0.08);
        }

        .match-entry.expanded {
            background: rgba(255,255,255,0.1);
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .expand-icon {
            font-size: 0.8em;
            color: #ffd700;
        }

        .match-rounds {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <button id="btnResetGame" class="settings-btn" title="Reset Game">üîÑ</button>
            <button id="btnHistory" class="settings-btn" title="History">üìä</button>
            <button id="btnSettings" class="settings-btn" title="Settings">‚öôÔ∏è</button>
            ‚öîÔ∏è War
        </h1>
    </div>
    
    <div class="game-area">
        <div class="player-zone opponent">
            <div class="player-info">
                <span class="player-name">Opponent</span>
                <div class="score-display">
                    <span class="score-item" id="oppWinDisplay" title="Total wins"><span id="oppWins">0</span> wins</span>
                    <span class="score-item" id="oppPointsDisplay" title="Points this game">Opp: <span id="oppPoints">0</span></span>
                </div>
            </div>
        </div>

        <div class="battle-zone">
            <div class="shared-deck-container">
                <div class="deck-preview" id="sharedDeck"></div>
                <div class="deck-label">Shared Deck: <span id="deckCount">52</span></div>
            </div>

            <div class="battle-cards" id="battleArea">
                <div class="battle-card">
                    <div id="oppCard"></div>
                    <div class="label">Opponent</div>
                </div>
                <div class="vs-text">VS</div>
                <div class="battle-card">
                    <div id="yourCard"></div>
                    <div class="label">You</div>
                </div>
            </div>
            <div class="message" id="message">Flip a card!</div>
            <div class="war-pot hidden" id="warPot">War pot: <span>0</span> cards</div>
        </div>

        <div class="player-zone">
            <div class="player-info">
                <span class="player-name">You</span>
                <div class="score-display">
                    <span class="score-item" id="yourWinDisplay" title="Total wins"><span id="yourWins">0</span> wins</span>
                    <span class="score-item" id="yourPointsDisplay" title="Points this game">You: <span id="yourPoints">0</span></span>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="control-row" id="playRow">
            <button class="btn btn-flip" id="btnFlip">Draw!</button>
        </div>
        <div class="control-row hidden" id="gameOverRow">
            <button class="btn btn-new" id="btnNew">Play Again</button>
        </div>
    </div>

    <div id="historyModal" class="modal-overlay hidden">
        <div class="modal">
            <h2>Game History</h2>

            <!-- Tab Navigation -->
            <div class="tab-nav">
                <button id="tabCurrentMatch" class="tab-btn active">Current Match</button>
                <button id="tabPreviousMatches" class="tab-btn">Previous Matches</button>
            </div>

            <!-- Tab Content: Current Match -->
            <div id="currentMatchTab" class="tab-content active">
                <div class="current-match-header">
                    <h3>Current Match (<span id="currentMatchRoundsCount">0</span> rounds)</h3>
                    <button id="btnClearCurrentMatch" class="secondary-btn small-btn">Clear</button>
                </div>
                <div id="currentMatchRoundsList" class="rounds-list"></div>
            </div>

            <!-- Tab Content: Previous Matches -->
            <div id="previousMatchesTab" class="tab-content hidden">
                <div class="history-stats">
                    <h3>Statistics</h3>
                    <div class="stat-row">
                        <div class="stat-item">
                            <div class="stat-value" id="totalWins">0</div>
                            <div class="stat-label">Wins</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalLosses">0</div>
                            <div class="stat-label">Losses</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="winRate">0%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                    </div>
                </div>

                <div id="historyList"></div>

                <button id="btnClearHistory" class="full-btn secondary-btn">Clear All History</button>
            </div>

            <button id="btnCloseHistory" class="full-btn close-btn">Close</button>
        </div>
    </div>

    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal">
            <h2>Game Settings</h2>

            <div class="setting-row">
                <label>Decks</label>
                <input type="number" id="cfgDecks" value="1" min="1" max="8" step="1">
            </div>

            <div class="setting-row">
                <label>2 beats Ace</label>
                <input type="checkbox" id="cfgTwosHigh">
            </div>

            <div class="setting-row multi-line">
                <div class="setting-header">
                    <label>Auto-Shuffle</label>
                    <input type="checkbox" id="cfgNeverending" checked>
                </div>
                <div class="setting-hint">
                    ON: Graveyard shuffles back into deck when empty.<br>
                    OFF: Game ends when deck is empty.
                </div>
            </div>

            <button id="btnNewGame" class="full-btn secondary-btn">New Game</button>
            <button id="btnResetRules" class="full-btn secondary-btn">Reset to Defaults</button>
            <button id="btnCloseSettings" class="full-btn primary-btn">Save & Close</button>
            <button id="btnCancelSettings" class="full-btn close-btn">Cancel</button>
        </div>
    </div>

    <!-- Auto-Shuffle Flash Modal -->
    <div id="autoShuffleFlash" class="auto-shuffle-flash hidden">
        <div class="flash-content">
            <span id="flashMessage">Auto-Shuffle: ON</span>
        </div>
    </div>

    <script src="../shared/enums.js"></script>
    <script src="../shared/card.js"></script>
    <script src="../shared/deck.js"></script>
    <script src="../shared/pile.js"></script>
    <script src="../shared/player.js"></script>
    <script src="../shared/engine.js"></script>
    <script src="../shared/card-assets.js"></script>
    <script src="../shared/card-utils.js"></script>
    <script src="ruleset.js"></script>
    
    <script>
        (function() {
            'use strict';

            CardAssets.init();

            var WarUI = function() {
                this.engine = new GameEngine(WarRuleset);
                this.currentPlayer1Card = null;
                this.currentPlayer2Card = null;
                this.gameHistory = [];
                this.player1Wins = 0;
                this.player2Wins = 0;
                this.player1Points = 0;
                this.player2Points = 0;
                this.isEndlessMode = true; // Default to endless/auto-shuffle
                this._previousDeckCount = undefined; // Track deck count for reshuffle detection

                // Battle history tracking (NEW)
                this.matchHistory = [];              // Array of match objects
                this.currentMatchId = null;          // ID of active match
                this.roundHistoryThreshold = 250;    // Max rounds to store
                this.nextMatchId = 1;                // Auto-increment counter

                this.el = {
                    oppWins: document.getElementById('oppWins'),
                    yourWins: document.getElementById('yourWins'),
                    oppPoints: document.getElementById('oppPoints'),
                    yourPoints: document.getElementById('yourPoints'),
                    oppWinDisplay: document.getElementById('oppWinDisplay'),
                    yourWinDisplay: document.getElementById('yourWinDisplay'),
                    oppPointsDisplay: document.getElementById('oppPointsDisplay'),
                    yourPointsDisplay: document.getElementById('yourPointsDisplay'),
                    sharedDeck: document.getElementById('sharedDeck'),
                    deckCount: document.getElementById('deckCount'),
                    oppCard: document.getElementById('oppCard'),
                    yourCard: document.getElementById('yourCard'),
                    message: document.getElementById('message'),
                    warPot: document.getElementById('warPot'),
                    playRow: document.getElementById('playRow'),
                    gameOverRow: document.getElementById('gameOverRow'),
                    btnFlip: document.getElementById('btnFlip'),
                    btnResetGame: document.getElementById('btnResetGame'),
                    btnNew: document.getElementById('btnNew'),
                    btnHistory: document.getElementById('btnHistory'),
                    btnSettings: document.getElementById('btnSettings'),
                    historyModal: document.getElementById('historyModal'),
                    settingsModal: document.getElementById('settingsModal'),
                    btnCloseHistory: document.getElementById('btnCloseHistory'),
                    btnClearHistory: document.getElementById('btnClearHistory'),
                    btnCloseSettings: document.getElementById('btnCloseSettings'),
                    btnCancelSettings: document.getElementById('btnCancelSettings'),
                    btnNewGame: document.getElementById('btnNewGame'),
                    btnResetRules: document.getElementById('btnResetRules'),
                    cfgDecks: document.getElementById('cfgDecks'),
                    cfgTwosHigh: document.getElementById('cfgTwosHigh'),
                    cfgNeverending: document.getElementById('cfgNeverending'),
                    historyList: document.getElementById('historyList'),
                    totalWins: document.getElementById('totalWins'),
                    totalLosses: document.getElementById('totalLosses'),
                    winRate: document.getElementById('winRate'),
                    autoShuffleFlash: document.getElementById('autoShuffleFlash'),
                    flashMessage: document.getElementById('flashMessage'),
                    tabCurrentMatch: document.getElementById('tabCurrentMatch'),
                    tabPreviousMatches: document.getElementById('tabPreviousMatches'),
                    currentMatchTab: document.getElementById('currentMatchTab'),
                    previousMatchesTab: document.getElementById('previousMatchesTab'),
                    currentMatchRoundsCount: document.getElementById('currentMatchRoundsCount'),
                    currentMatchRoundsList: document.getElementById('currentMatchRoundsList'),
                    btnClearCurrentMatch: document.getElementById('btnClearCurrentMatch')
                };

                this._bindEvents();
                this._subscribeToEngine();
                this._loadSettings();
                this._loadHistory();
                this._loadMatchHistory();  // Load battle history
                this._initGame();
            };

            WarUI.prototype._bindEvents = function() {
                var self = this;
                this.el.btnFlip.onclick = function() { self._flip(); };
                this.el.btnResetGame.onclick = function() { self._resetGame(); };
                this.el.btnNew.onclick = function() { self._initGame(); };

                // Win label click to toggle Auto-Shuffle
                this.el.yourWinDisplay.onclick = function() { self._toggleAutoShuffle(); };
                this.el.oppWinDisplay.onclick = function() { self._toggleAutoShuffle(); };

                // History Modal
                this.el.btnHistory.onclick = function() {
                    self._updateHistoryDisplay();
                    self.el.historyModal.classList.remove('hidden');
                };
                this.el.btnCloseHistory.onclick = function() {
                    self.el.historyModal.classList.add('hidden');
                };
                this.el.btnClearHistory.onclick = function() {
                    if (confirm('Clear all game history?')) {
                        self.gameHistory = [];
                        self._saveHistory();
                        self._updateHistoryDisplay();
                    }
                };
                this.el.historyModal.onclick = function(e) {
                    if (e.target === self.el.historyModal) {
                        self.el.historyModal.classList.add('hidden');
                    }
                };

                // Settings Modal
                this.el.btnSettings.onclick = function() {
                    self._loadSettings();
                    self.el.settingsModal.classList.remove('hidden');
                };
                this.el.btnCloseSettings.onclick = function() {
                    self._saveSettings();
                };
                this.el.btnCancelSettings.onclick = function() {
                    self._loadSettings();
                    self.el.settingsModal.classList.add('hidden');
                };
                this.el.btnNewGame.onclick = function() {
                    if (confirm('Start a new game? Current game will be lost.')) {
                        self.el.settingsModal.classList.add('hidden');
                        self._initGame();
                    }
                };
                this.el.btnResetRules.onclick = function() {
                    if (confirm('Reset to default settings?')) {
                        self.el.cfgDecks.value = 1;
                        self._saveSettings();
                    }
                };
                this.el.settingsModal.onclick = function(e) {
                    if (e.target === self.el.settingsModal) {
                        self._loadSettings();
                        self.el.settingsModal.classList.add('hidden');
                    }
                };

                // Tab switching
                this.el.tabCurrentMatch.onclick = function() {
                    self._switchTab('current');
                };
                this.el.tabPreviousMatches.onclick = function() {
                    self._switchTab('previous');
                };

                // Clear current match
                this.el.btnClearCurrentMatch.onclick = function() {
                    if (confirm('Clear current match? This will reset the match and start fresh.')) {
                        self._clearCurrentMatch();
                    }
                };
            };

            WarUI.prototype._subscribeToEngine = function() {
                var self = this;
                this.engine.on('*', function(event) {
                    console.log('[ALL EVENTS]', event.type, event);

                    switch (event.type) {
                        case 'MESSAGE':
                            self._handleMessage(event);
                            break;
                        case 'ROUND_WIN':
                            self._handleRoundWin(event);
                            break;
                        case 'RESOLUTION':
                            self._handleResolution(event);
                            break;
                        case 'GAME_OVER':
                            self._handleGameOver();
                            break;
                    }
                });
            };

            WarUI.prototype._initGame = function() {
                this.engine.init([
                    { id: 'player1', type: 'human', name: 'You' },
                    { id: 'player2', type: 'ai', name: 'Opponent' }
                ]);

                // War has no BETTING phase, go straight to DEALING
                this.engine.startRound();

                this._clearBattle();
                this._updateSharedDeck();
                this._showMessage('Draw a card!', '');
                this._updateButtonText();
                this.el.playRow.classList.remove('hidden');
                this.el.gameOverRow.classList.add('hidden');
                this.el.warPot.classList.add('hidden');

                this.currentPlayer1Card = null;
                this.currentPlayer2Card = null;

                // Only reset wins on very first initialization, not on "Play Again"
                // Check if wins are already set (if both are 0, might be first time)
                if (typeof this.player1Wins === 'undefined') {
                    this.player1Wins = 0;
                    this.player2Wins = 0;
                }

                // Always reset points for new game
                this.player1Points = 0;
                this.player2Points = 0;
                this._updateWins();
                this._updatePoints();

                // Start new match if needed
                var currentMatch = this._getCurrentMatch();
                if (!currentMatch || !currentMatch.isCurrentMatch) {
                    this._startNewMatch();
                }
            };

            WarUI.prototype._flip = function() {
                var state = this.engine.getGameState();
                if (state.state === 'GAME_OVER' || state.state === 'RESOLUTION') return;

                var player1 = state.players[0];
                var player2 = state.players[1];

                if (player1.hand.count === 0 || player2.hand.count === 0) {
                    return;
                }

                // Store and render cards BEFORE they move to war pot
                var card1 = player1.hand.contents[0];
                var card2 = player2.hand.contents[0];

                this._renderCard(card1, this.el.yourCard, true);
                this._renderCard(card2, this.el.oppCard, true);

                // Submit action to engine
                this.engine.submitAction('player1', 'flip');
            };

            WarUI.prototype._handleMessage = function(event) {
                this._showMessage(event.text, this._getMessageClass(event.text));
                this._updateSharedDeck();
                this._updateWarPot();
                this._updateButtonText();
            };

            WarUI.prototype._handleRoundWin = function(event) {
                console.log('[DEBUG] ROUND_WIN event received:', event);
                if (!event || !event.winner) {
                    console.log('[DEBUG] Invalid event - no winner');
                    return;
                }

                // Points increment when a player wins a round
                if (event.winner === 'player1') {
                    this.player1Points++;
                } else if (event.winner === 'player2') {
                    this.player2Points++;
                }
                this._updatePoints();

                // Add round entry to battle history
                if (this.currentPlayer1Card && this.currentPlayer2Card) {
                    this._addRoundEntry({
                        yourCard: {
                            suit: this.currentPlayer1Card.suit,
                            rank: this.currentPlayer1Card.rank
                        },
                        oppCard: {
                            suit: this.currentPlayer2Card.suit,
                            rank: this.currentPlayer2Card.rank
                        },
                        winner: event.winner === 'player1' ? 'you' : 'opponent',
                        isWar: false
                    });
                }

                // Check for deck depletion in non-endless mode
                if (!this.isEndlessMode) {
                    var state = this.engine.getGameState();
                    var player1 = state.players[0];
                    var player2 = state.players[1];
                    var totalCards = player1.hand.count + player2.hand.count;

                    // If deck is depleted or about to be (last cards drawn)
                    if (totalCards === 0 || (totalCards === 2 && !WarRuleset._warMode)) {
                        this._handleDeckDepletion();
                    }
                }

                console.log('[DEBUG] After round win - P1 points:', this.player1Points, 'P2 points:', this.player2Points, 'Endless:', this.isEndlessMode);
            };

            WarUI.prototype._handleDeckDepletion = function() {
                var winner;
                var message;

                // Determine winner based on points
                if (this.player1Points > this.player2Points) {
                    this.player1Wins++;
                    winner = 'player1';
                    message = 'üéâ You Win! (' + this.player1Points + ' points vs ' + this.player2Points + ')';
                } else if (this.player2Points > this.player1Points) {
                    this.player2Wins++;
                    winner = 'player2';
                    message = 'Opponent Wins! (' + this.player2Points + ' points vs ' + this.player1Points + ')';
                } else {
                    // Tie - no win awarded
                    message = 'Tie Game! Both had ' + this.player1Points + ' points';
                }

                this._updateWins();
                this._showMessage(message, winner === 'player1' ? 'win' : (winner === 'player2' ? 'lose' : ''));

                // Add history entry BEFORE resetting points
                if (winner) {
                    this._addHistoryEntry(winner === 'player1' ? 'win' : 'lose');
                    // End current match
                    this._endCurrentMatch(winner === 'player1' ? 'you' : 'opponent');
                    // FIX: Update the history modal now that we added a new entry
                    this._updateHistoryDisplay();
                }

                // Reset points for new game
                this.player1Points = 0;
                this.player2Points = 0;
                this._updatePoints();

                // Show "Play Again" button instead of auto-restarting
                this.el.playRow.classList.add('hidden');
                this.el.gameOverRow.classList.remove('hidden');
            };

            WarUI.prototype._handleResolution = function(event) {
                var self = this;
                setTimeout(function() {
                    self.engine.transitionTo('GAME_OVER');
                }, 800);
            };

            WarUI.prototype._handleGameOver = function() {
                var state = this.engine.getGameState();
                var player1 = state.players[0];
                var player2 = state.players[1];

                // In endless mode, this should never happen
                if (this.isEndlessMode) {
                    console.warn('[GAME_OVER] Called in endless mode - should not happen');
                    return;
                }

                // Non-endless mode: Determine winner based on points
                var winner;
                var message;

                if (this.player1Points > this.player2Points) {
                    this.player1Wins++;
                    winner = 'player1';
                    message = 'üéâ You Win! (' + this.player1Points + ' points vs ' + this.player2Points + ')';
                } else if (this.player2Points > this.player1Points) {
                    this.player2Wins++;
                    winner = 'player2';
                    message = 'Opponent Wins! (' + this.player2Points + ' points vs ' + this.player1Points + ')';
                } else {
                    // Tie - no win awarded
                    message = 'Tie Game! Both had ' + this.player1Points + ' points';
                }

                this._updateWins();
                this._showMessage(message, winner === 'player1' ? 'win' : (winner === 'player2' ? 'lose' : ''));

                // Add history entry BEFORE resetting points
                if (winner) {
                    this._addHistoryEntry(winner === 'player1' ? 'win' : 'lose');
                    // End current match
                    this._endCurrentMatch(winner === 'player1' ? 'you' : 'opponent');
                    // Update the history modal now that we added a new entry
                    this._updateHistoryDisplay();
                }

                // Reset points for new game
                this.player1Points = 0;
                this.player2Points = 0;
                this._updatePoints();

                // Show "Play Again" button instead of auto-restarting
                this.el.playRow.classList.add('hidden');
                this.el.gameOverRow.classList.remove('hidden');
            };

            WarUI.prototype._resetDeckAndContinue = function() {
                // Reinitialize the game with a fresh deck
                WarRuleset.initializeGame(this.engine.getGameState());

                // Clear the battle display
                this._clearBattle();

                // Update displays
                this._updateSharedDeck();
                this._showMessage('New deck! Draw to continue.', '');

                console.log('[RESET] Deck reset - fresh 52 cards dealt');
            };

            WarUI.prototype._resetGame = function() {
                if (this.isEndlessMode) {
                    // Endless mode: Keep stats, just reset deck
                    if (confirm('Reset game? Stats will be preserved.')) {
                        this._resetDeckAndContinue();
                    }
                } else {
                    // Non-endless mode: Offer full reset or just deck
                    var choice = confirm('Reset deck only (OK) or reset entire game including wins and history (Cancel)?');
                    if (choice) {
                        // Just reset deck
                        this._resetDeckAndContinue();
                    } else {
                        // Full reset - clear wins, points, and history
                        this.player1Wins = 0;
                        this.player2Wins = 0;
                        this.player1Points = 0;
                        this.player2Points = 0;
                        this.gameHistory = [];
                        this._saveHistory();
                        this._updateWins();
                        this._updatePoints();
                        this._initGame();
                    }
                }
            };

            WarUI.prototype._toggleAutoShuffle = function() {
                // Toggle the mode
                this.isEndlessMode = !this.isEndlessMode;
                WarRuleset.neverending = this.isEndlessMode;

                // Sync settings checkbox
                this.el.cfgNeverending.checked = this.isEndlessMode;

                // Save to localStorage
                this._saveSettings();

                // Show flash message (0.5s or 0.25s for mode toggle)
                this._showAutoShuffleFlash(this.isEndlessMode ? 'ON' : 'OFF', 250);

                // Update display
                this._updateWins();
            };

            WarUI.prototype._showAutoShuffleFlash = function(mode, duration) {
                var self = this;
                var flashDiv = this.el.autoShuffleFlash;
                var messageSpan = this.el.flashMessage;

                messageSpan.textContent = 'Auto-Shuffle: ' + mode;

                // Show flash
                flashDiv.classList.remove('hidden');
                setTimeout(function() {
                    flashDiv.classList.add('show');
                }, 10);

                // Auto-dismiss after duration
                var dismissTimeout = setTimeout(function() {
                    self._hideAutoShuffleFlash();
                }, duration);

                // Click to dismiss
                flashDiv.onclick = function() {
                    clearTimeout(dismissTimeout);
                    self._hideAutoShuffleFlash();
                };
            };

            WarUI.prototype._showAutoShuffleFireFlash = function() {
                var self = this;
                var flashDiv = this.el.autoShuffleFlash;
                var messageSpan = this.el.flashMessage;

                messageSpan.textContent = 'Auto-Shuffle!';

                // Show flash (faster - 0.25s for firing)
                flashDiv.classList.remove('hidden');
                setTimeout(function() {
                    flashDiv.classList.add('show');
                }, 10);

                var dismissTimeout = setTimeout(function() {
                    self._hideAutoShuffleFlash();
                }, 250);

                flashDiv.onclick = function() {
                    clearTimeout(dismissTimeout);
                    self._hideAutoShuffleFlash();
                };
            };

            WarUI.prototype._hideAutoShuffleFlash = function() {
                var flashDiv = this.el.autoShuffleFlash;
                flashDiv.classList.remove('show');
                setTimeout(function() {
                    flashDiv.classList.add('hidden');
                }, 150);
            };

            WarUI.prototype._renderCard = function(card, container, animate) {
                var rankKey = RankToAsset[card.rank];
                var suitKey = SuitToAsset[card.suit];
                var canvas = CardAssets.getAsset(rankKey, suitKey);

                var clone = document.createElement('canvas');
                clone.width = canvas.width;
                clone.height = canvas.height;
                clone.getContext('2d').drawImage(canvas, 0, 0);

                // Clear container first to prevent accumulation
                container.innerHTML = '';

                // Add animation class if requested
                if (animate) {
                    if (container === this.el.oppCard) {
                        clone.classList.add('slide-in-from-top');
                    } else if (container === this.el.yourCard) {
                        clone.classList.add('slide-in-from-bottom');
                    }

                    // Remove animation class after it completes to prevent issues
                    clone.addEventListener('animationend', function() {
                        clone.classList.remove('slide-in-from-top');
                        clone.classList.remove('slide-in-from-bottom');
                    });
                }

                container.appendChild(clone);
            };

            WarUI.prototype._renderCardBack = function(container) {
                var canvas = CardAssets.getAsset();
                var clone = document.createElement('canvas');
                clone.width = canvas.width;
                clone.height = canvas.height;
                clone.getContext('2d').drawImage(canvas, 0, 0);
                container.innerHTML = '';
                container.appendChild(clone);
            };

            WarUI.prototype._updateSharedDeck = function() {
                var state = this.engine.getGameState();
                var player1 = state.players[0];
                var player2 = state.players[1];

                // Shared deck shows only cards in players' hands (drawable cards)
                var totalCards = player1.hand.count + player2.hand.count;

                console.log('[DECK UPDATE] P1:', player1.hand.count, 'P2:', player2.hand.count, 'Total:', totalCards, 'Graveyard:', WarRuleset._graveyard ? WarRuleset._graveyard.count : 0, 'WarPot:', WarRuleset._warPot ? WarRuleset._warPot.count : 0);

                // Detect graveyard reshuffle: if deck count increased and we're in endless mode
                if (this.isEndlessMode && this._previousDeckCount !== undefined && totalCards > this._previousDeckCount) {
                    // Graveyard was reshuffled back into deck
                    this._showAutoShuffleFireFlash();
                }

                this._previousDeckCount = totalCards;
                this.el.deckCount.textContent = totalCards;

                // Render shared deck if there are cards
                if (totalCards > 0) {
                    this._renderCardBack(this.el.sharedDeck);
                } else {
                    this.el.sharedDeck.innerHTML = '';
                }
            };

            WarUI.prototype._clearBattle = function() {
                this.el.yourCard.innerHTML = '';
                this.el.oppCard.innerHTML = '';
            };

            WarUI.prototype._updateWins = function() {
                // Update win display (show infinity symbol if endless mode)
                if (this.isEndlessMode) {
                    this.el.yourWins.innerHTML = '&infin;';
                    this.el.oppWins.innerHTML = '&infin;';
                } else {
                    this.el.yourWins.textContent = this.player1Wins;
                    this.el.oppWins.textContent = this.player2Wins;
                }
            };

            WarUI.prototype._updatePoints = function() {
                this.el.yourPoints.textContent = this.player1Points;
                this.el.oppPoints.textContent = this.player2Points;
            };

            WarUI.prototype._updateWarPot = function() {
                var potSize = WarRuleset._warPot.count;
                this.el.warPot.querySelector('span').textContent = potSize;
                if (potSize > 0) {
                    this.el.warPot.classList.remove('hidden');
                } else {
                    this.el.warPot.classList.add('hidden');
                }
            };

            WarUI.prototype._showMessage = function(text, cls) {
                this.el.message.textContent = text;
                this.el.message.className = 'message ' + (cls || '');
            };

            WarUI.prototype._getMessageClass = function(text) {
                if (text.indexOf('You win') !== -1 || text.indexOf('Win') !== -1) return 'win';
                if (text.indexOf('Opponent wins') !== -1) return 'lose';
                if (text.indexOf('WAR') !== -1) return 'war';
                return '';
            };

            WarUI.prototype._updateButtonText = function() {
                var isWar = WarRuleset._warMode;
                this.el.btnFlip.textContent = isWar ? 'War!' : 'Draw!';
            };

            // Settings Management
            WarUI.prototype._loadSettings = function() {
                var savedJson = localStorage.getItem('war_config');
                if (savedJson) {
                    try {
                        var saved = JSON.parse(savedJson);
                        WarRuleset.deckCount = saved.deckCount || 1;
                        WarRuleset.twosHigh = saved.twosHigh || false;
                        
                        // FIX: Explicitly check against false to ensure default is true
                        WarRuleset.neverending = saved.neverending !== false;
                    } catch(e) {
                        WarRuleset.neverending = true;
                    }
                } else {
                    // FIX: Default to true if no settings exist
                    WarRuleset.neverending = true;
                }
                
                this.el.cfgDecks.value = WarRuleset.deckCount || 1;
                this.el.cfgTwosHigh.checked = WarRuleset.twosHigh || false;
                
                // Update checkbox to match the ruleset
                this.el.cfgNeverending.checked = WarRuleset.neverending;

                // Sync UI's endless mode flag
                this.isEndlessMode = WarRuleset.neverending;
            };

            WarUI.prototype._saveSettings = function() {
                var deckValue = parseInt(this.el.cfgDecks.value);
                if (isNaN(deckValue) || deckValue <= 0) {
                    deckValue = 1;
                }
                WarRuleset.deckCount = deckValue;
                WarRuleset.twosHigh = this.el.cfgTwosHigh.checked;
                WarRuleset.neverending = this.el.cfgNeverending.checked;

                // Update UI's endless mode flag
                this.isEndlessMode = WarRuleset.neverending;

                localStorage.setItem('war_config', JSON.stringify({
                    deckCount: WarRuleset.deckCount,
                    twosHigh: WarRuleset.twosHigh,
                    neverending: WarRuleset.neverending
                }));

                // Update display to reflect new mode
                this._updateWins();
                this._showMessage(this.isEndlessMode ? 'Auto-Shuffle Enabled' : 'Auto-Shuffle Disabled', '');

                this.el.settingsModal.classList.add('hidden');
            };

            // History Management
            WarUI.prototype._loadHistory = function() {
                var savedJson = localStorage.getItem('war_history');
                if (savedJson) {
                    try {
                        this.gameHistory = JSON.parse(savedJson);
                    } catch(e) {
                        this.gameHistory = [];
                    }
                }
            };

            WarUI.prototype._saveHistory = function() {
                localStorage.setItem('war_history', JSON.stringify(this.gameHistory));
            };

            WarUI.prototype._addHistoryEntry = function(result) {
                var entry = {
                    matchId: 'match_' + Date.now(),
                    date: new Date().toLocaleString(),
                    winner: result, // 'win' or 'lose' or 'tie'
                    player1Points: this.player1Points,
                    player2Points: this.player2Points,
                    endReason: 'deck_depletion'
                };
                console.log('[HISTORY] Adding entry:', entry);
                this.gameHistory.unshift(entry);
                if (this.gameHistory.length > 50) {
                    this.gameHistory.pop();
                }
                this._saveHistory();
                console.log('[HISTORY] Total matches:', this.gameHistory.length);
            };

            WarUI.prototype._updateHistoryDisplay = function() {
                var wins = 0;
                var losses = 0;

                for (var i = 0; i < this.gameHistory.length; i++) {
                    var entry = this.gameHistory[i];
                    // Handle both old format (result) and new format (winner)
                    var result = entry.winner || entry.result;
                    if (result === 'win') wins++;
                    else if (result === 'lose') losses++;
                }

                var total = wins + losses;
                var winRate = total > 0 ? Math.round((wins / total) * 100) : 0;

                this.el.totalWins.textContent = wins;
                this.el.totalLosses.textContent = losses;
                this.el.winRate.textContent = winRate + '%';

                var html = '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">';
                html += '<thead><tr style="border-bottom: 1px solid #444;">';
                html += '<th style="padding: 8px; text-align: left;">Date</th>';
                html += '<th style="padding: 8px; text-align: center;">Winner</th>';
                html += '<th style="padding: 8px; text-align: right;">Your Points</th>';
                html += '<th style="padding: 8px; text-align: right;">Opp Points</th>';
                html += '</tr></thead><tbody>';

                for (var j = 0; j < Math.min(this.gameHistory.length, 50); j++) {
                    var entry = this.gameHistory[j];
                    var result = entry.winner || entry.result;
                    var resultClass = result === 'win' ? 'win' : (result === 'lose' ? 'lose' : '');
                    var resultText = result === 'win' ? '‚úì You' : (result === 'lose' ? '‚úó Opp' : '„Äú Tie');
                    var yourPoints = entry.player1Points !== undefined ? entry.player1Points : '-';
                    var oppPoints = entry.player2Points !== undefined ? entry.player2Points : '-';

                    html += '<tr style="border-bottom: 1px solid #333;" class="' + resultClass + '">';
                    html += '<td style="padding: 6px;">' + entry.date + '</td>';
                    html += '<td style="padding: 6px; text-align: center;">' + resultText + '</td>';
                    html += '<td style="padding: 6px; text-align: right;">' + yourPoints + '</td>';
                    html += '<td style="padding: 6px; text-align: right;">' + oppPoints + '</td>';
                    html += '</tr>';
                }

                html += '</tbody></table>';

                this.el.historyList.innerHTML = this.gameHistory.length > 0 ? html : '<p style="text-align: center; color: #888;">No games played yet</p>';
            };

            // Override _updateHistoryDisplay to call new rendering methods
            var oldUpdateHistoryDisplay = WarUI.prototype._updateHistoryDisplay;
            WarUI.prototype._updateHistoryDisplay = function() {
                // Update both tabs
                this._renderCurrentMatchTab();
                this._renderPreviousMatchesTab();
            };

            // ========================================================================
            // BATTLE HISTORY RENDERING METHODS
            // ========================================================================

            WarUI.prototype._renderCurrentMatchTab = function() {
                var currentMatch = this._getCurrentMatch();

                // If no current match exists, try to start one
                if (!currentMatch) {
                    console.log('[BATTLE HISTORY] No current match found, starting new one');
                    this._startNewMatch();
                    currentMatch = this._getCurrentMatch();
                }

                if (!currentMatch || !currentMatch.rounds || currentMatch.rounds.length === 0) {
                    this.el.currentMatchRoundsList.innerHTML = '<p class="no-history">No rounds played yet.</p>';
                    this.el.currentMatchRoundsCount.textContent = '0';
                    return;
                }

                this.el.currentMatchRoundsCount.textContent = currentMatch.rounds.length;

                var html = '';

                // Show rounds in reverse order (newest first)
                for (var i = currentMatch.rounds.length - 1; i >= 0; i--) {
                    var round = currentMatch.rounds[i];
                    html += this._renderRoundEntry(round);
                }

                this.el.currentMatchRoundsList.innerHTML = html;
            };

            WarUI.prototype._renderRoundEntry = function(round) {
                var winClass = round.winner === 'you' ? '' : ' lose';
                var warClass = round.isWar ? ' war' : '';

                var html = '<div class="round-entry' + winClass + warClass + '">';

                // Round header
                html += '<div class="round-header">';
                html += '<span class="round-id">#' + round.roundId + '</span>';
                html += '<span class="round-time">' + this._formatTime(round.timestamp) + '</span>';
                html += '</div>';

                // Cards
                html += '<div class="round-cards">';
                html += '<span>You: ' + CardUtils.renderCardHTML(round.yourCard) + '</span>';
                html += '<span class="vs">vs</span>';
                html += '<span>Opp: ' + CardUtils.renderCardHTML(round.oppCard) + '</span>';
                html += '</div>';

                // War sequence (if applicable)
                if (round.isWar && round.warSequence) {
                    html += '<div class="war-sequence">';
                    html += '<strong>‚öîÔ∏è WAR!</strong><br>';
                    html += 'You: ' + CardUtils.renderCardListHTML(round.warSequence.yourHidden);
                    html += ' ‚Üí ' + CardUtils.renderCardHTML(round.warSequence.yourFlipped) + '<br>';
                    html += 'Opp: ' + CardUtils.renderCardListHTML(round.warSequence.oppHidden);
                    html += ' ‚Üí ' + CardUtils.renderCardHTML(round.warSequence.oppFlipped);
                    html += '</div>';
                }

                // Winner
                html += '<div class="round-winner' + winClass + '">';
                html += '‚Üí ' + (round.winner === 'you' ? 'You Win' : 'Opponent Wins');
                html += '</div>';

                html += '</div>';
                return html;
            };

            WarUI.prototype._renderPreviousMatchesTab = function() {
                // Calculate stats from matchHistory
                var wins = 0;
                var losses = 0;

                for (var i = 0; i < this.matchHistory.length; i++) {
                    var match = this.matchHistory[i];
                    if (match.winner === 'you') wins++;
                    else if (match.winner === 'opponent') losses++;
                }

                // Also count from old gameHistory for backwards compatibility
                for (var j = 0; j < this.gameHistory.length; j++) {
                    var entry = this.gameHistory[j];
                    var result = entry.winner || entry.result;
                    if (result === 'win') wins++;
                    else if (result === 'lose') losses++;
                }

                var total = wins + losses;
                var winRate = total > 0 ? Math.round((wins / total) * 100) : 0;

                this.el.totalWins.textContent = wins;
                this.el.totalLosses.textContent = losses;
                this.el.winRate.textContent = winRate + '%';

                // Render match list (excluding current match)
                var html = '';

                for (var k = this.matchHistory.length - 1; k >= 0; k--) {
                    var matchEntry = this.matchHistory[k];

                    // Skip current match
                    if (matchEntry.isCurrentMatch) {
                        continue;
                    }

                    html += this._renderMatchEntry(matchEntry);
                }

                // Also render old gameHistory for backwards compatibility
                if (this.gameHistory.length > 0) {
                    html += '<h4 style="margin: 16px 0 8px; color: #888; font-size: 0.9em;">Legacy Matches:</h4>';
                    var legacyHTML = '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">';
                    legacyHTML += '<thead><tr style="border-bottom: 1px solid #444;">';
                    legacyHTML += '<th style="padding: 8px; text-align: left;">Date</th>';
                    legacyHTML += '<th style="padding: 8px; text-align: center;">Winner</th>';
                    legacyHTML += '<th style="padding: 8px; text-align: right;">Your Points</th>';
                    legacyHTML += '<th style="padding: 8px; text-align: right;">Opp Points</th>';
                    legacyHTML += '</tr></thead><tbody>';

                    for (var m = 0; m < Math.min(this.gameHistory.length, 50); m++) {
                        var gameEntry = this.gameHistory[m];
                        var gameResult = gameEntry.winner || gameEntry.result;

                        legacyHTML += '<tr style="border-bottom: 1px solid #333;">';
                        legacyHTML += '<td style="padding: 8px;">' + gameEntry.date + '</td>';
                        legacyHTML += '<td style="padding: 8px; text-align: center; color: ' + (gameResult === 'win' ? '#4ade80' : (gameResult === 'lose' ? '#ef4444' : '#888')) + '">';
                        legacyHTML += (gameResult === 'win' ? 'You' : (gameResult === 'lose' ? 'Opponent' : 'Tie'));
                        legacyHTML += '</td>';
                        legacyHTML += '<td style="padding: 8px; text-align: right;">' + gameEntry.player1Points + '</td>';
                        legacyHTML += '<td style="padding: 8px; text-align: right;">' + gameEntry.player2Points + '</td>';
                        legacyHTML += '</tr>';
                    }

                    legacyHTML += '</tbody></table>';
                    html += legacyHTML;
                }

                if (html === '') {
                    html = '<p class="no-history">No previous matches yet.</p>';
                }

                this.el.historyList.innerHTML = html;
            };

            WarUI.prototype._renderMatchEntry = function(match) {
                var matchDate = new Date(match.timestamp).toLocaleString();
                var winnerText = match.winner === 'you' ? 'You Won' : 'Opponent Won';
                var winnerColor = match.winner === 'you' ? '#4ade80' : '#ef4444';

                var html = '<div class="match-entry" id="match-' + match.matchId + '" onclick="warUI._toggleMatchExpand(' + match.matchId + ')">';

                // Match header (always visible)
                html += '<div class="match-header">';
                html += '<div>';
                html += '<strong>Match #' + match.matchId + '</strong> - ' + matchDate + '<br>';
                html += '<span style="color: ' + winnerColor + '">' + winnerText + '</span>';
                html += ' | ' + match.totalRounds + ' rounds';
                html += ' | You ' + match.yourFinalScore + ' - Opp ' + match.oppFinalScore;
                html += '</div>';
                html += '<span class="expand-icon">‚ñ∂</span>';
                html += '</div>';

                // Match rounds (collapsible)
                html += '<div class="match-rounds" id="match-rounds-' + match.matchId + '" style="display: none;">';
                if (match.hasRoundHistory && match.rounds && match.rounds.length > 0) {
                    for (var r = 0; r < match.rounds.length; r++) {
                        html += this._renderRoundEntry(match.rounds[r]);
                    }
                } else {
                    html += '<p class="no-history">Round history unavailable (pruned to save space)</p>';
                }
                html += '</div>';

                html += '</div>';
                return html;
            };

            WarUI.prototype._toggleMatchExpand = function(matchId) {
                var matchDiv = document.getElementById('match-' + matchId);
                var roundsDiv = document.getElementById('match-rounds-' + matchId);
                var expandIcon = matchDiv ? matchDiv.querySelector('.expand-icon') : null;

                if (roundsDiv && expandIcon) {
                    if (roundsDiv.style.display === 'none') {
                        roundsDiv.style.display = 'block';
                        expandIcon.textContent = '‚ñº';
                        matchDiv.classList.add('expanded');
                    } else {
                        roundsDiv.style.display = 'none';
                        expandIcon.textContent = '‚ñ∂';
                        matchDiv.classList.remove('expanded');
                    }
                }
            };

            WarUI.prototype._formatTime = function(timestamp) {
                var date = new Date(timestamp);
                return date.toLocaleTimeString();
            };

            // ========================================================================
            // MATCH HISTORY METHODS (Battle-by-Battle Tracking)
            // ========================================================================

            WarUI.prototype._saveMatchHistory = function() {
                try {
                    var json = JSON.stringify(this.matchHistory);
                    localStorage.setItem('war_match_history', json);
                } catch(e) {
                    console.error('[MATCH HISTORY] Failed to save:', e);
                }
            };

            WarUI.prototype._loadMatchHistory = function() {
                try {
                    var json = localStorage.getItem('war_match_history');
                    if (json) {
                        this.matchHistory = JSON.parse(json);

                        // Find highest match ID for auto-increment
                        for (var i = 0; i < this.matchHistory.length; i++) {
                            if (this.matchHistory[i].matchId >= this.nextMatchId) {
                                this.nextMatchId = this.matchHistory[i].matchId + 1;
                            }

                            // Set current match ID
                            if (this.matchHistory[i].isCurrentMatch) {
                                this.currentMatchId = this.matchHistory[i].matchId;
                            }
                        }
                    }
                } catch(e) {
                    console.error('[MATCH HISTORY] Failed to load:', e);
                    this.matchHistory = [];
                }
            };

            WarUI.prototype._startNewMatch = function() {
                var match = {
                    matchId: this.nextMatchId++,
                    timestamp: Date.now(),
                    winner: null,
                    yourFinalScore: this.player1Points,
                    oppFinalScore: this.player2Points,
                    totalRounds: 0,
                    hasRoundHistory: true,
                    isCurrentMatch: true,
                    rounds: []
                };

                // Mark previous match as not current
                if (this.matchHistory.length > 0) {
                    var lastMatch = this.matchHistory[this.matchHistory.length - 1];
                    lastMatch.isCurrentMatch = false;
                }

                this.matchHistory.push(match);
                this.currentMatchId = match.matchId;
                this._saveMatchHistory();
                console.log('[MATCH HISTORY] Started new match:', match.matchId);
            };

            WarUI.prototype._getCurrentMatch = function() {
                for (var i = 0; i < this.matchHistory.length; i++) {
                    if (this.matchHistory[i].matchId === this.currentMatchId) {
                        return this.matchHistory[i];
                    }
                }
                return null;
            };

            WarUI.prototype._endCurrentMatch = function(winner) {
                var match = this._getCurrentMatch();
                if (match) {
                    match.winner = winner;
                    match.yourFinalScore = this.player1Points;
                    match.oppFinalScore = this.player2Points;
                    match.isCurrentMatch = false;
                    this._saveMatchHistory();
                    console.log('[MATCH HISTORY] Ended match:', match.matchId, 'Winner:', winner);
                }
            };

            WarUI.prototype._addRoundEntry = function(roundData) {
                var currentMatch = this._getCurrentMatch();
                if (!currentMatch) {
                    // No current match - start one
                    console.log('[BATTLE HISTORY] No current match in _addRoundEntry, starting new one');
                    this._startNewMatch();
                    currentMatch = this._getCurrentMatch();
                }

                // Add round to current match
                roundData.roundId = currentMatch.rounds.length + 1;
                roundData.timestamp = Date.now();
                currentMatch.rounds.push(roundData);
                currentMatch.totalRounds++;

                console.log('[BATTLE HISTORY] Round #' + roundData.roundId + ' added. Total rounds:', currentMatch.totalRounds);

                // Check if we need to prune old match histories
                this._pruneRoundHistoryIfNeeded();

                // Save to localStorage
                this._saveMatchHistory();
            };

            WarUI.prototype._getTotalRoundCount = function() {
                var total = 0;
                for (var i = 0; i < this.matchHistory.length; i++) {
                    if (this.matchHistory[i].hasRoundHistory && this.matchHistory[i].rounds) {
                        total += this.matchHistory[i].rounds.length;
                    }
                }
                return total;
            };

            WarUI.prototype._pruneRoundHistoryIfNeeded = function() {
                var totalRounds = this._getTotalRoundCount();

                // If under threshold, nothing to do
                if (totalRounds <= this.roundHistoryThreshold) {
                    return;
                }

                console.log('[PRUNE] Total rounds:', totalRounds, '> threshold:', this.roundHistoryThreshold);

                // Delete oldest match round histories (but NOT current match)
                for (var i = 0; i < this.matchHistory.length; i++) {
                    var match = this.matchHistory[i];

                    // Skip current match - always keep it
                    if (match.isCurrentMatch) {
                        continue;
                    }

                    // Delete this match's round history
                    if (match.hasRoundHistory) {
                        console.log('[PRUNE] Deleting match', match.matchId, 'rounds:', match.rounds.length);
                        delete match.rounds;
                        match.hasRoundHistory = false;

                        // Recalculate total
                        totalRounds = this._getTotalRoundCount();

                        // If now under threshold, stop
                        if (totalRounds <= this.roundHistoryThreshold) {
                            console.log('[PRUNE] Now under threshold:', totalRounds);
                            break;
                        }
                    }
                }
            };

            WarUI.prototype._switchTab = function(tab) {
                if (tab === 'current') {
                    this.el.tabCurrentMatch.classList.add('active');
                    this.el.tabPreviousMatches.classList.remove('active');
                    this.el.currentMatchTab.classList.add('active');
                    this.el.currentMatchTab.classList.remove('hidden');
                    this.el.previousMatchesTab.classList.remove('active');
                    this.el.previousMatchesTab.classList.add('hidden');
                } else {
                    this.el.tabCurrentMatch.classList.remove('active');
                    this.el.tabPreviousMatches.classList.add('active');
                    this.el.currentMatchTab.classList.remove('active');
                    this.el.currentMatchTab.classList.add('hidden');
                    this.el.previousMatchesTab.classList.add('active');
                    this.el.previousMatchesTab.classList.remove('hidden');
                }
                // Refresh display
                this._updateHistoryDisplay();
            };

            WarUI.prototype._clearCurrentMatch = function() {
                var currentMatch = this._getCurrentMatch();
                if (currentMatch) {
                    // Remove from history
                    for (var i = 0; i < this.matchHistory.length; i++) {
                        if (this.matchHistory[i].matchId === this.currentMatchId) {
                            this.matchHistory.splice(i, 1);
                            break;
                        }
                    }
                }

                // Reset points
                this.player1Points = 0;
                this.player2Points = 0;
                this._updatePoints();

                // Start fresh match
                this._startNewMatch();
                this._saveMatchHistory();
                this._updateHistoryDisplay();
            };

            // Make warUI globally accessible for onclick handlers
            var warUI = new WarUI();
        })();
    </script>
</body>
</html>