// Expanded File List generated from repo scan
var FILES = [
    // Root
    { category: "Root", name: "README", path: "../../README.md" },
    { category: "Root", name: "AI Feedback", path: "../../AI_FEEDBACK.md" },
    { category: "Root", name: "Agents", path: "../../AGENTS.md" },
    { category: "Root", name: "Changelog", path: "../../CHANGELOG.md" },
    { category: "Root", name: "Roadmap", path: "../../ROADMAP.md" },
    { category: "Root", name: "Info", path: "../../INFO.md" },
    { category: "Root", name: "Ideas (02/04/26)", path: "../../IDEAS_020426.md" },
    { category: "Root", name: "Questions", path: "../../QUESTIONS.md" },
    { category: "Root", name: "Wiki Plan", path: "../../WIKI-PLAN.md" },
    { category: "Root", name: "Todo", path: "../../TODO.md" },
    { category: "Root", name: "Project Registry", path: "../../PROJECTS.md" },
    { category: "Root", name: "Master Manual", path: "../../docs/MASTER_MANUAL.md" },

    // Agent Guidelines
    { category: "Agent Guidelines", name: "Claude", path: "../../CLAUDE.md" },
    { category: "Agent Guidelines", name: "Gemini", path: "../../GEMINI.md" },
    { category: "Agent Guidelines", name: "Jules", path: "../../JULES.md" },
    { category: "Agent Guidelines", name: "Claude Assessment", path: "../../CLAUDE_ASSESSMENT.md" },
    { category: "Agent Guidelines", name: "Onboarding", path: "../../ONBOARDING.md" },

    // NEGEN Engine
    { category: "NEGEN Engine", name: "User Manual", path: "../../docs/negen/USER_MANUAL.md" },
    { category: "NEGEN Engine", name: "Technical Reference", path: "../../docs/negen/TECHNICAL_REFERENCE.md" },
    { category: "NEGEN Engine", name: "History & Changelog", path: "../../docs/negen/HISTORY.md" },
    { category: "NEGEN Engine", name: "Architecture Plan", path: "../../negen/NEGEN_PLAN.md" },
    { category: "NEGEN Engine", name: "Progress Tracker", path: "../../negen/PROGRESS.md" },
    { category: "NEGEN Engine", name: "Phase 2 Specs", path: "../../negen/PHASE_2_SPECS.md" },
    { category: "NEGEN Engine", name: "Phase 3 Plan", path: "../../negen/PHASE_3_PLAN.md" },
    { category: "NEGEN Engine", name: "Phase 4 Plan", path: "../../negen/PHASE_4_PLAN.md" },
    { category: "NEGEN Engine", name: "Phase 5 Plan", path: "../../negen/PHASE_5_PLAN.md" },
    { category: "NEGEN Engine", name: "Overhaul Plan", path: "../../negen/OVERHAUL_PLAN.md" },
    { category: "NEGEN Engine", name: "Arcade Roadmap", path: "../../negen/ARCADE_ROADMAP.md" },
    { category: "NEGEN Engine", name: "Engine Readme", path: "../../negen/README.md" },

    // Project Docs
    { category: "Project Specs", name: "Snake", path: "../../docs/projects/SNAKE.md" },
    { category: "Project Specs", name: "Slots", path: "../../docs/projects/SLOTS.md" },
    { category: "Project Specs", name: "Shared", path: "../../docs/projects/SHARED.md" },
    { category: "Project Specs", name: "XTC Ball", path: "../../docs/projects/XTC_BALL.md" },
    { category: "Project Specs", name: "Sprunki", path: "../../docs/projects/SPRUNKI.md" },
    { category: "Project Specs", name: "Cards", path: "../../docs/projects/CARDS.md" },
    { category: "Project Specs", name: "Flow", path: "../../docs/projects/FLOW.md" },

    // Cookbook
    { category: "Cookbook", name: "Asado", path: "../../projects/md-reader/recipes/asado.md" },
    { category: "Cookbook", name: "Cacik", path: "../../projects/md-reader/recipes/cacik.md" },
    { category: "Cookbook", name: "Flan", path: "../../projects/md-reader/recipes/flan.md" },
    { category: "Cookbook", name: "Kabse", path: "../../projects/md-reader/recipes/kabse.md" },
    { category: "Cookbook", name: "Migas", path: "../../projects/md-reader/recipes/migas.md" },

    // Lessons Learned
    { category: "Lessons Learned", name: "Index", path: "../../LL/README.md" },
    { category: "Lessons Learned", name: "Card Engine", path: "../../LL/LL_CARD_ENGINE.md" },
    { category: "Lessons Learned", name: "ES5 & Safari", path: "../../LL/LL_ES5_SAFARI.md" },
    { category: "Lessons Learned", name: "Collaboration", path: "../../LL/LL_COLLABORATION.md" },

    // Games
    { category: "Games", name: "Snake LL v1", path: "../../games/snake/LL_v1_snake.md" },
    { category: "Games", name: "Snake LL v2", path: "../../games/snake/LL_v2_snake.md" },
    { category: "Games", name: "Sprunki Readme", path: "../../games/sprunki/README.md" },
    { category: "Games", name: "XTC Ball LL", path: "../../games/xtc_ball/LL_v5_XTCBALL.md" },
    { category: "Games", name: "Flow Readme", path: "../../games/flow/README.md" },
    { category: "Games", name: "Flow Changelog", path: "../../games/flow/CHANGELOG.md" },
    { category: "Games", name: "Flow Architecture", path: "../../games/flow/ARCHITECTURE.md" },
    { category: "Games", name: "Cards Changelog", path: "../../games/cards/changelog.md" },
    { category: "Games", name: "Card Engine Guide", path: "../../games/cards/shared/CARD_ENGINE_GUIDE.md" },
    { category: "Games", name: "Blackjack Info", path: "../../games/cards/blackjack/INFO.md" },
    { category: "Games", name: "War Info", path: "../../games/cards/war/INFO.md" },

    // Shipment Tracker
    { category: "Shipment Tracker", name: "Readme", path: "../../projects/shipment-tracker/README.md" },
    { category: "Shipment Tracker", name: "Changelog", path: "../../projects/shipment-tracker/CHANGELOG.md" },
    { category: "Shipment Tracker", name: "DB Usage", path: "../../projects/shipment-tracker/docs/DB_USAGE.md" },
    { category: "Shipment Tracker", name: "Architecture", path: "../../projects/shipment-tracker/ARCHITECTURE.md" },
    { category: "Shipment Tracker", name: "API Guide", path: "../../projects/shipment-tracker/API_SETUP_GUIDE.md" },

    // Admin
    { category: "Admin", name: "Upgrade Checklist", path: "../../admin/UPGRADE_CHECKLIST.md" },
    { category: "Admin", name: "Dependency Policy", path: "../../admin/DEPENDENCY_POLICY.md" },
    { category: "Space Invaders", name: "Manual", path: "../../games/space_invaders/MANUAL.md" },
    { category: "Space Invaders", name: "Technical", path: "../../games/space_invaders/TECHNICAL.md" },
    { category: "Sky Breakers", name: "Manual", path: "../../games/sky_breakers/MANUAL.md" },
    { category: "Sky Breakers", name: "Technical", path: "../../games/sky_breakers/TECHNICAL.md" },
    { category: "Breakout", name: "Manual", path: "../../games/breakout/MANUAL.md" },
    { category: "Breakout", name: "Technical", path: "../../games/breakout/TECHNICAL.md" },
    { category: "Animal Stack", name: "Manual", path: "../../games/animal_stack/MANUAL.md" },
    { category: "Animal Stack", name: "Technical", path: "../../games/animal_stack/TECHNICAL.md" },
    { category: "Pong", name: "Manual", path: "../../games/pong/MANUAL.md" },
    { category: "Pong", name: "Technical", path: "../../games/pong/TECHNICAL.md" },
    { category: "Tracing", name: "Manual", path: "../../games/tracing/MANUAL.md" },
    { category: "Tracing", name: "Technical", path: "../../games/tracing/TECHNICAL.md" },
    { category: "Board Arcade", name: "Manual", path: "../../games/board/MANUAL.md" },
    { category: "Board Arcade", name: "Technical", path: "../../games/board/TECHNICAL.md" },
    { category: "Blackjack", name: "Manual", path: "../../games/cards/blackjack/MANUAL.md" },
    { category: "Blackjack", name: "Technical", path: "../../games/cards/blackjack/TECHNICAL.md" },
    { category: "War", name: "Manual", path: "../../games/cards/war/MANUAL.md" },
    { category: "War", name: "Technical", path: "../../games/cards/war/TECHNICAL.md" },
    { category: "5 Card Draw", name: "Manual", path: "../../games/cards/poker/5card/MANUAL.md" },
    { category: "5 Card Draw", name: "Technical", path: "../../games/cards/poker/5card/TECHNICAL.md" },
    { category: "13 Card Poker", name: "Manual", path: "../../games/cards/poker/13card/MANUAL.md" },
    { category: "13 Card Poker", name: "Technical", path: "../../games/cards/poker/13card/TECHNICAL.md" },
    { category: "Texas Hold'em", name: "Manual", path: "../../games/cards/poker/holdem/MANUAL.md" },
    { category: "Texas Hold'em", name: "Technical", path: "../../games/cards/poker/holdem/TECHNICAL.md" },
];

// Imported files storage (session-based)
var importedFiles = {};
var currentFilePath = null;

// Infinite Scroll Globals
var allTokens = [];
var currentTokenIndex = 0;
var globalRenderer = null;
var renderingPath = null;

// View Mode & History
var viewMode = 'parsed'; // 'parsed' or 'raw'
var recentFiles = [];

document.addEventListener('DOMContentLoaded', function() {
    loadImportedFromSession();
    loadHistory();
    initTheme();
    init();
});

// --- Theme Management ---
function initTheme() {
    var storedTheme = localStorage.getItem('mdReader_theme') || 'dark';

    // Check if custom theme data exists
    if (storedTheme === 'custom') {
        loadCustomTheme();
    }

    setTheme(storedTheme);

    // Bind theme buttons
    document.querySelectorAll('.theme-opt').forEach(function(btn) {
        btn.addEventListener('click', function() {
            var theme = btn.getAttribute('data-theme');
            if (theme === 'custom') {
                openCustomThemeEditor();
                toggleSettingsMenu(false);
            } else {
                setTheme(theme);
                toggleSettingsMenu(false);
            }
        });
    });

    initCustomThemeEditor();
}

function setTheme(theme) {
    document.body.setAttribute('data-theme', theme);
    localStorage.setItem('mdReader_theme', theme);

    // Update Highlight.js theme
    var hljsLink = document.getElementById('hljs-theme');
    if (hljsLink) {
        if (theme === 'light' || theme === 'solarized') {
             hljsLink.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css";
        } else if (theme === 'high-contrast') {
             hljsLink.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css";
        } else {
             hljsLink.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";
        }
    }

    // If switching away from custom, clean up inline styles?
    // No, keep them in case they switch back, but the attribute selector in CSS will override standard vars
    // actually, inline styles override CSS classes. So we need to clear them if not custom.
    if (theme !== 'custom') {
        document.body.removeAttribute('style');
    } else {
        loadCustomTheme(); // Re-apply if switching back to custom
    }
}

// --- History Management ---
function loadHistory() {
    try {
        recentFiles = JSON.parse(localStorage.getItem('mdReader_recent') || '[]');
    } catch (e) {
        console.error("Failed to load history", e);
    }
}

function updateHistory(path) {
    if (path.startsWith('imported:')) return; // Don't save imported files to persistent history

    try {
        localStorage.setItem('mdReader_lastFile', path);

        // Remove if exists
        var idx = recentFiles.indexOf(path);
        if (idx !== -1) recentFiles.splice(idx, 1);

        // Add to top
        recentFiles.unshift(path);

        // Limit to 10
        if (recentFiles.length > 10) recentFiles.pop();

        localStorage.setItem('mdReader_recent', JSON.stringify(recentFiles));
        renderSidebar(); // Refresh sidebar
    } catch (e) {
        console.error("Failed to save history", e);
    }
}

function loadImportedFromSession() {
    try {
        var stored = sessionStorage.getItem('mdReaderImported');
        if (stored) {
            importedFiles = JSON.parse(stored);
        }
    } catch (e) {
        console.error('Failed to load imported files:', e);
    }
}

function saveImportedToSession() {
    try {
        sessionStorage.setItem('mdReaderImported', JSON.stringify(importedFiles));
    } catch (e) {
        console.error('Failed to save imported files:', e);
    }
}

function init() {
    setupSearch();
    setupExpandCollapse();
    renderSidebar();
    setupFileUpload();

    // View Toggle
    var toggleViewBtn = document.getElementById('toggleView');
    if (toggleViewBtn) {
        toggleViewBtn.addEventListener('click', function() {
            viewMode = (viewMode === 'parsed') ? 'raw' : 'parsed';
            toggleViewBtn.textContent = (viewMode === 'parsed') ? 'üëÅÔ∏è Parsed' : 'üìù Raw';
            if (currentFilePath) {
                 if (currentFilePath.startsWith('imported:')) {
                     var filename = currentFilePath.replace('imported:', '');
                     if (importedFiles[filename]) renderMarkdown(importedFiles[filename], filename);
                 } else {
                     loadFile(currentFilePath);
                 }
            }
        });
    }

    // Check for hash to load initial file
    var hash = window.location.hash.slice(1);
    if (hash) {
        if (hash.startsWith('imported:')) {
            var filename = hash.replace('imported:', '');
            if (importedFiles[filename]) {
                loadImportedFile(filename);
            } else {
                loadFile(FILES[0].path);
            }
        } else {
            // Fix path if coming from external link to ensure relative correctness
            var path = decodeURIComponent(hash);
            // If path is "games/snake/README.md" and we are in "projects/md-reader/",
            // we need to make sure it's "../../games/snake/README.md" if not absolute/http.
            if (!path.startsWith('http') && !path.startsWith('../../') && !path.startsWith('/') && !path.startsWith('./')) {
                 path = '../../' + path;
            }
            loadFile(path);
        }
    } else {
        // Load last opened or default
        var last = localStorage.getItem('mdReader_lastFile');
        if (last) {
            loadFile(last);
        } else {
            loadFile(FILES[0].path);
        }
    }

    // Sidebar toggle
    var toggleBtn = document.getElementById('toggleSidebar');
    var sidebar = document.getElementById('sidebar');
    var overlay = document.getElementById('sidebarOverlay');

    if (toggleBtn) {
        toggleBtn.addEventListener('click', function() {
            if (window.innerWidth > 768) {
                sidebar.classList.toggle('collapsed');
            } else {
                sidebar.classList.toggle('open');
                if (overlay) overlay.classList.toggle('active');
            }
        });
    }

    if (overlay) {
        overlay.addEventListener('click', function() {
            closeSidebar();
        });
    }

    // Settings Menu
    var settingsBtn = document.getElementById('settingsBtn');
    var settingsMenu = document.getElementById('settingsMenu');

    if (settingsBtn && settingsMenu) {
        settingsBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleSettingsMenu();
        });

        // Close when clicking outside
        document.addEventListener('click', function(e) {
            if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) {
                toggleSettingsMenu(false);
            }
        });
    }

    // Print Button
    var printBtn = document.getElementById('printBtn');
    if (printBtn) {
        printBtn.addEventListener('click', function() {
            window.print();
            toggleSettingsMenu(false);
        });
    }

    // Infinite Scroll Listener
    var container = document.getElementById('markdownContent');
    if (container) {
        container.addEventListener('scroll', function() {
            if (container.scrollHeight - container.scrollTop - container.clientHeight < 1000) {
                renderNextChunk();
            }
        });
    }

    // Custom path form
    var form = document.getElementById('customPathForm');
    if (form) {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            var input = document.getElementById('customPathInput');
            if (input.value.trim()) {
                loadFile(input.value.trim());
                closeSidebar();
            }
        });
    }

    // Open in new tab button
    var openNewTabBtn = document.getElementById('openNewTab');
    if (openNewTabBtn) {
        openNewTabBtn.addEventListener('click', openInNewTab);
    }

    // Listen for hash changes (Back/Forward navigation)
    window.addEventListener('hashchange', function() {
        var hash = window.location.hash.slice(1);
        if (hash) {
            if (hash.startsWith('imported:')) {
                var filename = hash.replace('imported:', '');
                if (importedFiles[filename]) {
                    loadImportedFile(filename);
                }
            } else {
                 var path = decodeURIComponent(hash);
                 if (!path.startsWith('http') && !path.startsWith('../../') && !path.startsWith('/') && !path.startsWith('./')) {
                     path = '../../' + path;
                 }
                 // Avoid reloading if just setting hash from loadFile
                 if (path !== currentFilePath) {
                     loadFile(path);
                 }
            }
        }
    });
}

function toggleSettingsMenu(forceState) {
    var menu = document.getElementById('settingsMenu');
    if (!menu) return;

    if (typeof forceState === 'boolean') {
        if (forceState) menu.classList.add('show');
        else menu.classList.remove('show');
    } else {
        menu.classList.toggle('show');
    }
}

function setupSearch() {
    var searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            renderSidebar(e.target.value);
        });
    }
}

function setupExpandCollapse() {
    var expandAll = document.getElementById('expandAllBtn');
    var collapseAll = document.getElementById('collapseAllBtn');

    if (expandAll) {
        expandAll.addEventListener('click', function() {
            document.querySelectorAll('.category-group').forEach(function(el) {
                el.classList.remove('collapsed');
                var icon = el.querySelector('.cat-icon');
                if (icon) icon.textContent = '‚ñº';
            });
        });
    }

    if (collapseAll) {
        collapseAll.addEventListener('click', function() {
            document.querySelectorAll('.category-group').forEach(function(el) {
                el.classList.add('collapsed');
                var icon = el.querySelector('.cat-icon');
                if (icon) icon.textContent = '‚ñ∂';
            });
        });
    }
}

function closeSidebar() {
    var sidebar = document.getElementById('sidebar');
    var overlay = document.getElementById('sidebarOverlay');
    sidebar.classList.remove('open');
    if (overlay) overlay.classList.remove('active');
}

function setupFileUpload() {
    var uploadArea = document.getElementById('uploadArea');
    var fileInput = document.getElementById('fileUploadInput');

    if (!uploadArea || !fileInput) return;

    uploadArea.addEventListener('click', function() {
        fileInput.click();
    });

    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', function() {
        uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        if (e.dataTransfer.files.length > 0) {
            handleFileUpload(e.dataTransfer.files[0]);
        }
    });

    fileInput.addEventListener('change', function() {
        if (fileInput.files.length > 0) {
            handleFileUpload(fileInput.files[0]);
        }
    });
}

function handleFileUpload(file) {
    if (!file.name.match(/\.(md|markdown|txt)$/i)) {
        alert('Please upload a markdown file (.md, .markdown, or .txt)');
        return;
    }

    var reader = new FileReader();
    reader.onload = function(e) {
        var content = e.target.result;
        var filename = file.name;

        // Store in session
        importedFiles[filename] = content;
        saveImportedToSession();

        // Re-render sidebar to show new file
        renderSidebar();

        // Load the imported file
        loadImportedFile(filename);
    };
    reader.readAsText(file);
}

function removeImportedFile(filename, event) {
    event.stopPropagation();
    delete importedFiles[filename];
    saveImportedToSession();
    renderSidebar();

    // If this was current file, load default
    if (currentFilePath === 'imported:' + filename) {
        loadFile(FILES[0].path);
    }
}

function loadImportedFile(filename) {
    var content = importedFiles[filename];
    if (!content) return;

    currentFilePath = 'imported:' + filename;
    window.location.hash = 'imported:' + filename;

    var pathDisplay = document.getElementById('currentPath');
    pathDisplay.textContent = filename + ' (imported)';

    renderMarkdown(content, filename);

    // Update active state
    document.querySelectorAll('.file-btn').forEach(function(b) {
        b.classList.remove('active');
    });
    var importedBtn = document.querySelector('[data-imported="' + filename + '"]');
    if (importedBtn) importedBtn.classList.add('active');

    closeSidebar();
}

function renderSidebar(searchTerm) {
    searchTerm = (searchTerm || '').toLowerCase();
    var list = document.getElementById('fileList');
    if (!list) return;
    list.innerHTML = '';

    // Render Recent Files (only if no search term)
    if (!searchTerm && recentFiles.length > 0) {
        var recentHeader = document.createElement('li');
        recentHeader.innerHTML = '<div style="padding: 10px 15px; font-size: 0.8em; text-transform: uppercase; color: #60a5fa; opacity: 0.9; font-weight: bold; margin-top: 10px;">üïí Recent</div>';
        list.appendChild(recentHeader);

        recentFiles.forEach(function(path) {
            // Find name in FILES if possible
            var fileObj = FILES.find(f => f.path === path);
            var name = fileObj ? fileObj.name : path.split('/').pop();

            var li = document.createElement('li');
            li.className = 'file-item';
            var btn = document.createElement('button');
            btn.className = 'file-btn';
            btn.innerHTML = '<span style="opacity: 0.7;">üìÑ</span> ' + name;
            btn.addEventListener('click', function() {
                loadFile(path);
                closeSidebar();
            });
            list.appendChild(li);
        });
    }

    // Filter: If search term exists, use REPO_FILES (comprehensive). Else use FILES (curated sidebar).
    var sourceFiles = (searchTerm && typeof REPO_FILES !== 'undefined') ? REPO_FILES : FILES;

    // Sort logic: If searching, flat list might be better, but grouping still works if categorized well.
    // Let's stick to grouping for now as REPO_FILES has categories.

    var filteredFiles = sourceFiles.filter(function(file) {
        if (!searchTerm) return true;
        return file.name.toLowerCase().includes(searchTerm) ||
               file.path.toLowerCase().includes(searchTerm);
    });

    // Group by category
    var categories = {};
    filteredFiles.forEach(function(file) {
        var cat = file.category || "Uncategorized";
        if (!categories[cat]) {
            categories[cat] = [];
        }
        categories[cat].push(file);
    });

    // If searching, auto-expand all categories
    var autoExpand = !!searchTerm;

    // Render repo files
    Object.keys(categories).forEach(function(category) {
        var files = categories[category];

        var categoryLi = document.createElement('li');
        categoryLi.className = 'category-group';

        if (!autoExpand) {
             categoryLi.classList.add('collapsed');
        } else {
             // If expanded, remove collapsed (redundant but safe)
             categoryLi.classList.remove('collapsed');
        }

        // Header
        var header = document.createElement('div');
        header.className = 'category-header';
        // Fix: Use correct initial arrow state based on collapsed class
        var arrow = (!autoExpand) ? '‚ñ∂' : '‚ñº';
        header.innerHTML = '<span class="cat-icon">' + arrow + '</span> <span class="cat-name">' + category + '</span> <span class="cat-count">' + files.length + '</span>';

        // Container for files
        var fileContainer = document.createElement('ul');
        fileContainer.className = 'category-files';

        header.addEventListener('click', function() {
            categoryLi.classList.toggle('collapsed');
            var icon = header.querySelector('.cat-icon');
            icon.textContent = categoryLi.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
        });

        files.forEach(function(file) {
            var li = document.createElement('li');
            li.className = 'file-item';

            var btn = document.createElement('button');
            btn.className = 'file-btn';

            // Icon based on type if available (from REPO_FILES merging)
            var icon = 'üìÑ';
            if (file.type === 'csv') icon = 'üìä';
            else if (file.type === 'json') icon = 'Curly Braces';
            else if (file.type === 'js') icon = 'üìú';
            else if (file.type === 'html') icon = 'üåê';

            btn.innerHTML = '<span style="opacity: 0.7;">' + icon + '</span> ' + file.name;
            btn.addEventListener('click', function() {
                loadFile(file.path);
                document.querySelectorAll('.file-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                btn.classList.add('active');
                closeSidebar();
            });

            if (window.location.hash.slice(1) === file.path) {
                btn.classList.add('active');
                categoryLi.classList.remove('collapsed'); // Auto expand if active file is inside
                header.querySelector('.cat-icon').textContent = '‚ñº';
            }

            li.appendChild(btn);
            fileContainer.appendChild(li);
        });

        categoryLi.appendChild(header);
        categoryLi.appendChild(fileContainer);
        list.appendChild(categoryLi);
    });

    // Filter Imported Files
    var importedKeys = Object.keys(importedFiles).filter(function(filename) {
        if (!searchTerm) return true;
        return filename.toLowerCase().includes(searchTerm);
    });

    // Render imported files section
    if (importedKeys.length > 0) {
        var importedHeader = document.createElement('li');
        importedHeader.innerHTML = '<div style="padding: 10px 15px; font-size: 0.8em; text-transform: uppercase; color: #fbbf24; opacity: 0.9; font-weight: bold; margin-top: 10px;">üì• Imported (Session)</div>';
        list.appendChild(importedHeader);

        importedKeys.forEach(function(filename) {
            var li = document.createElement('li');
            li.className = 'file-item';

            var btn = document.createElement('button');
            btn.className = 'file-btn imported-file';
            btn.setAttribute('data-imported', filename);
            btn.innerHTML = '<span style="opacity: 0.7;">üìÑ</span> <span class="imported-name">' + filename + '</span> <span class="remove-btn" title="Remove from session">‚úï</span>';

            btn.addEventListener('click', function(e) {
                if (e.target.classList.contains('remove-btn')) {
                    removeImportedFile(filename, e);
                } else {
                    loadImportedFile(filename);
                }
            });

            if (window.location.hash === '#imported:' + filename) {
                btn.classList.add('active');
            }

            li.appendChild(btn);
            list.appendChild(li);
        });
    }
}

function loadFile(path) {
    var container = document.getElementById('markdownContent');
    var pathDisplay = document.getElementById('currentPath');

    currentFilePath = path;
    window.location.hash = path;
    pathDisplay.textContent = path;

    container.innerHTML = '<div class="loading">Loading...</div>';

    // Cookbook Menu Handling
    if (path.endsWith('.menu.md')) {
        fetch(path)
            .then(res => res.text())
            .then(text => renderRecipeMenu(text, path))
            .catch(err => {
                container.innerHTML = '<div class="error-message">Error loading menu: ' + err.message + '</div>';
            });
        return;
    }

    fetch(path)
        .then(function(response) {
            if (!response.ok) {
                throw new Error('Failed to load file: ' + response.status + ' ' + response.statusText);
            }
            return response.text();
        })
        .then(function(text) {
            // Large file check (1MB)
            if (text.length > 1000000) {
                var sizeMB = (text.length / 1024 / 1024).toFixed(2);
                if (!confirm('This file is very large (' + sizeMB + ' MB). Loading it might freeze the browser temporarily. Load anyway?')) {
                    container.innerHTML = '<div class="error-message">Load cancelled by user.</div>';
                    return;
                }
            }
            updateHistory(path);
            renderMarkdown(text, path);
        })
        .catch(function(error) {
            console.error(error);
            container.innerHTML = '<div class="error-message">' +
                '<h3>Error Loading File</h3>' +
                '<p>Could not load <code>' + path + '</code></p>' +
                '<p style="font-size: 0.9em; opacity: 0.8;">' + error.message + '</p>' +
                '<p style="font-size: 0.8em; margin-top: 20px;">Note: If you are opening this file directly from the file system (file://), this is expected due to security restrictions (CORS). You need to serve the directory via a local web server.</p>' +
                '</div>';
        });
}

function renderMarkdown(text, path) {
    var container = document.getElementById('markdownContent');

    if (typeof marked === 'undefined') {
        container.innerHTML = '<div class="error-message">Error: marked.js library not loaded.</div>';
        return;
    }

    // Cookbook Logic: Check for Frontmatter
    if (text.trim().startsWith('---')) {
        try {
            var parts = text.split('---');
            if (parts.length >= 3) {
                var frontmatterRaw = parts[1];
                // Join back in case body contains '---'
                var body = parts.slice(2).join('---');

                if (typeof jsyaml !== 'undefined') {
                    var frontmatter = jsyaml.load(frontmatterRaw);
                    // Check if it's a recipe
                    if (frontmatter && (frontmatter.ingredients || frontmatter.steps || frontmatter.type === 'recipe')) {
                        renderCookbook(frontmatter, body, path);
                        return;
                    }
                }
            }
        } catch (e) {
            console.warn("Frontmatter parsing failed", e);
        }
    }

    marked.setOptions({
        highlight: function(code, lang) {
            if (typeof hljs !== 'undefined') {
                var language = hljs.getLanguage(lang) ? lang : 'plaintext';
                return hljs.highlight(code, { language: language }).value;
            }
            return code;
        },
        langPrefix: 'hljs language-',
        breaks: true,
        gfm: true
    });

    var renderer = new marked.Renderer();
    var originalImage = renderer.image;

    renderer.image = function(href, title, text) {
        if (path && href && !href.startsWith('http') && !href.startsWith('/')) {
            if (path.includes('/')) {
                var lastSlash = path.lastIndexOf('/');
                if (lastSlash !== -1) {
                    var basePath = path.substring(0, lastSlash + 1);
                    href = basePath + href;
                }
            }
        }
        return originalImage.call(this, href, title, text);
    };

    globalRenderer = renderer;
    renderingPath = path;

    if (viewMode === 'raw') {
        container.innerHTML = '<pre style="white-space: pre-wrap; word-break: break-all;"><code>' +
            escapeHtml(text) +
            '</code></pre>';
        container.scrollTop = 0;
        return;
    }

    // Determine extension for rendering strategy
    var ext = path ? path.split('.').pop().toLowerCase() : 'md';

    // CSV Rendering
    if (ext === 'csv') {
        renderCsv(text, container);
        return;
    }

    // Code Rendering (Generic) - if not MD/Markdown
    if (ext !== 'md' && ext !== 'markdown' && ext !== 'txt') {
        // Try to map extension to language for highlight.js
        var lang = ext;
        if (lang === 'js') lang = 'javascript';
        if (lang === 'py') lang = 'python';
        if (lang === 'html') lang = 'xml';

        container.innerHTML = '<pre><code class="language-' + lang + '">' + escapeHtml(text) + '</code></pre>';
        hljs.highlightAll();
        container.scrollTop = 0;
        return;
    }

    // BBC Translation (Only for MD/TXT)
    text = convertBbcToMarkdown(text);

    try {
        // Use lexer to get tokens for chunking
        allTokens = marked.lexer(text);
        currentTokenIndex = 0;

        container.innerHTML = '';
        container.scrollTop = 0;

        renderNextChunk();
    } catch (e) {
        container.innerHTML = '<div class="error-message">Error parsing markdown: ' + e.message + '</div>';
    }
}

function escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function renderCsv(text, container) {
    try {
        var rows = text.trim().split('\n');
        if (rows.length === 0) return;

        var html = '<div style="overflow-x:auto;"><table>';

        rows.forEach(function(row, i) {
            html += '<tr>';
            var cols = row.split(','); // Simple split, doesn't handle quoted commas
            cols.forEach(function(col) {
                if (i === 0) html += '<th>' + escapeHtml(col.trim()) + '</th>';
                else html += 'td>' + escapeHtml(col.trim()) + '</td>';
            });
            html += '</tr>';
        });

        html += '</table></div>';
        container.innerHTML = html;
        container.scrollTop = 0;
    } catch(e) {
        container.innerHTML = '<div class="error-message">Error parsing CSV: ' + e.message + '</div>';
    }
}

function convertBbcToMarkdown(text) {
    return text
        .replace(/\[b\](.*?)\[\/b\]/gi, '**$1**')
        .replace(/\[i\](.*?)\[\/i\]/gi, '*$1*')
        .replace(/\[u\](.*?)\[\/u\]/gi, '<u>$1</u>')
        .replace(/\[url=(.*?)\](.*?)\[\/url\]/gi, '[$2]($1)')
        .replace(/\[img\](.*?)\[\/img\]/gi, '![]($1)')
        .replace(/\[code\]([\s\S]*?)\[\/code\]/gi, '```\n$1\n```')
        .replace(/\[quote\]([\s\S]*?)\[\/quote\]/gi, '> $1');
}

function renderNextChunk() {
    if (currentTokenIndex >= allTokens.length) return;

    var chunkSize = 50; // Render 50 top-level blocks at a time
    var chunk = allTokens.slice(currentTokenIndex, currentTokenIndex + chunkSize);
    // Pass links from parent
    chunk.links = allTokens.links;

    currentTokenIndex += chunkSize;

    try {
        var html = marked.parser(chunk, { renderer: globalRenderer });

        // Create a temp div to hold the new content
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;

        // Append children to container
        var container = document.getElementById('markdownContent');
        while (tempDiv.firstChild) {
            container.appendChild(tempDiv.firstChild);
        }
    } catch (e) {
        console.error("Error rendering chunk:", e);
    }
}

function openInNewTab() {
    if (!currentFilePath) return;

    if (currentFilePath.startsWith('imported:')) {
        var filename = currentFilePath.replace('imported:', '');
        var content = importedFiles[filename];
        if (!content) return;

        var html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>' + filename + '</title>' +
            '<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"><\/script>' +
            '<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">' +
            '<style>body{font-family:system-ui;max-width:900px;margin:0 auto;padding:40px;background:#0f172a;color:#f8fafc;line-height:1.6;}' +
            'a{color:#ffd700;}code{background:rgba(110,118,129,0.4);padding:2px 6px;border-radius:4px;}' +
            'pre{background:#1e1e1e;padding:16px;border-radius:6px;overflow-x:auto;border:1px solid rgba(255,255,255,0.1);}' +
            'pre code{background:transparent;padding:0;}' +
            'table{border-collapse:collapse;width:100%;}th,td{border:1px solid rgba(255,255,255,0.1);padding:8px 12px;}' +
            'h1{color:#ffd700;border-bottom:1px solid rgba(255,255,255,0.1);padding-bottom:8px;}' +
            'h2{border-bottom:1px solid rgba(255,255,255,0.1);padding-bottom:8px;}</style></head>' +
            '<body><div id="content"></div><script>' +
            'document.getElementById("content").innerHTML = marked.parse(' + JSON.stringify(content) + ');<\/script></body></html>';
        var blob = new Blob([html], {type: 'text/html'});
        var url = URL.createObjectURL(blob);
        window.open(url, '_blank');
    } else {
        window.open(currentFilePath, '_blank');
    }
}

// --- Custom Theme Logic ---
function initCustomThemeEditor() {
    var modal = document.getElementById('customThemeEditor');
    var close = document.getElementById('closeCte');
    var save = document.getElementById('cte-save');
    var reset = document.getElementById('cte-reset');
    var inputs = {
        bg: document.getElementById('cte-bg'),
        text: document.getElementById('cte-text'),
        accent: document.getElementById('cte-accent'),
        bgSec: document.getElementById('cte-bg-sec')
    };

    close.addEventListener('click', function() {
        modal.classList.remove('active');
    });

    save.addEventListener('click', function() {
        var themeData = {
            '--bg-primary': inputs.bg.value,
            '--text-primary': inputs.text.value,
            '--accent': inputs.accent.value,
            '--bg-secondary': inputs.bgSec.value,
            // Derived
            '--border': adjustColor(inputs.bgSec.value, 20),
            '--code-bg': inputs.bgSec.value,
            '--text-secondary': adjustColor(inputs.text.value, -40)
        };

        localStorage.setItem('mdReader_custom_theme', JSON.stringify(themeData));
        applyCustomTheme(themeData);
        setTheme('custom');
        modal.classList.remove('active');
    });

    reset.addEventListener('click', function() {
        // Reset inputs to dark theme defaults
        inputs.bg.value = '#0f172a';
        inputs.text.value = '#f8fafc';
        inputs.accent.value = '#38bdf8';
        inputs.bgSec.value = '#1e293b';
    });
}

function openCustomThemeEditor() {
    var modal = document.getElementById('customThemeEditor');
    modal.classList.add('active');

    // Load current values if custom
    var stored = localStorage.getItem('mdReader_custom_theme');
    if (stored) {
        var data = JSON.parse(stored);
        document.getElementById('cte-bg').value = data['--bg-primary'] || '#000000';
        document.getElementById('cte-text').value = data['--text-primary'] || '#ffffff';
        document.getElementById('cte-accent').value = data['--accent'] || '#00ffff';
        document.getElementById('cte-bg-sec').value = data['--bg-secondary'] || '#111111';
    }
}

function loadCustomTheme() {
    var stored = localStorage.getItem('mdReader_custom_theme');
    if (stored) {
        applyCustomTheme(JSON.parse(stored));
    }
}

function applyCustomTheme(data) {
    for (var key in data) {
        document.body.style.setProperty(key, data[key]);
    }
}

function adjustColor(hex, amount) {
    // Basic implementation to lighten/darken hex color
    var usePound = false;
    if (hex[0] == "#") {
        hex = hex.slice(1);
        usePound = true;
    }
    var num = parseInt(hex, 16);
    var r = (num >> 16) + amount;
    if (r > 255) r = 255; else if (r < 0) r = 0;
    var b = ((num >> 8) & 0x00FF) + amount;
    if (b > 255) b = 255; else if (b < 0) b = 0;
    var g = (num & 0x0000FF) + amount;
    if (g > 255) g = 255; else if (g < 0) g = 0;
    return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16);
}

// --- Cookbook Logic ---

function renderCookbook(frontmatter, body, path) {
    var container = document.getElementById('markdownContent');
    container.innerHTML = '';

    // Create Dashboard Container
    var dashboard = document.createElement('div');
    dashboard.className = 'cookbook-dashboard';

    // --- Left Column: Mise-en-place ---
    var colLeft = document.createElement('div');
    colLeft.className = 'cookbook-col col-left';

    var title = document.createElement('h1');
    title.textContent = frontmatter.title || 'Recipe';
    colLeft.appendChild(title);

    // Meta Info
    var meta = document.createElement('div');
    meta.className = 'recipe-meta';
    if (frontmatter.total_time) {
        meta.innerHTML += '<div>‚è±Ô∏è ' + frontmatter.total_time + ' min</div>';
    }
    colLeft.appendChild(meta);

    // Servings Scaler
    var servingsContainer = document.createElement('div');
    servingsContainer.className = 'servings-control';
    var baseServings = frontmatter.servings || 1;
    servingsContainer.innerHTML =
        '<label>Servings:</label>' +
        '<input type="number" id="servingsInput" value="' + baseServings + '" min="1" style="width: 60px; margin-left: 10px;">';
    colLeft.appendChild(servingsContainer);

    // Ingredients List
    var ingList = document.createElement('ul');
    ingList.className = 'ingredient-list';
    ingList.id = 'ingredientList';

    var ingredients = frontmatter.ingredients || [];
    // Store original ingredients for scaling
    ingList.dataset.ingredients = JSON.stringify(ingredients);
    ingList.dataset.baseServings = baseServings;

    colLeft.appendChild(ingList);
    dashboard.appendChild(colLeft);

    // --- Center Column: The Guide ---
    var colCenter = document.createElement('div');
    colCenter.className = 'cookbook-col col-center';

    var stepsHeader = document.createElement('h2');
    stepsHeader.textContent = 'Instructions';
    colCenter.appendChild(stepsHeader);

    if (frontmatter.steps && Array.isArray(frontmatter.steps)) {
        var stepsContainer = document.createElement('div');
        stepsContainer.className = 'steps-container';

        frontmatter.steps.forEach(function(step, index) {
            var card = document.createElement('div');
            card.className = 'step-card';
            card.innerHTML =
                '<div class="step-time">' + (step.time !== undefined ? 'T+' + step.time + 'm' : 'Step ' + (index + 1)) + '</div>' +
                '<div class="step-action">' + marked.parse(step.action) + '</div>';

            card.addEventListener('click', function() {
                this.classList.toggle('active');
            });
            stepsContainer.appendChild(card);
        });
        colCenter.appendChild(stepsContainer);
    } else {
        // Fallback to markdown body
        var bodyContent = document.createElement('div');
        bodyContent.className = 'markdown-body';
        bodyContent.innerHTML = marked.parse(body);
        colCenter.appendChild(bodyContent);
    }
    dashboard.appendChild(colCenter);

    // --- Right Column: Visuals ---
    var colRight = document.createElement('div');
    colRight.className = 'cookbook-col col-right';

    // Try to find image
    var imgSrc = frontmatter.image;
    if (!imgSrc) {
        // Regex to find first image in markdown body
        var match = body.match(/!\[.*?\]\((.*?)\)/);
        if (match) imgSrc = match[1];
    }

    if (imgSrc) {
         // Fix relative path if needed
         if (!imgSrc.startsWith('http') && !imgSrc.startsWith('/') && path.includes('/')) {
             var lastSlash = path.lastIndexOf('/');
             imgSrc = path.substring(0, lastSlash + 1) + imgSrc;
         }

        var hero = document.createElement('img');
        hero.className = 'hero-image';
        hero.src = imgSrc;
        colRight.appendChild(hero);
    }

    dashboard.appendChild(colRight);
    container.appendChild(dashboard);

    // Init Logic
    renderIngredients(ingredients, 1); // 1 = ratio (base/base)
    checkPantry(ingredients);

    // Bind Scaler
    document.getElementById('servingsInput').addEventListener('change', function(e) {
        var newServings = parseFloat(e.target.value);
        var ratio = newServings / baseServings;
        renderIngredients(ingredients, ratio);
        checkPantry(ingredients); // Re-check pantry
    });
}

function renderIngredients(ingredients, ratio) {
    var list = document.getElementById('ingredientList');
    list.innerHTML = '';

    ingredients.forEach(function(ing) {
        var li = document.createElement('li');
        li.className = 'ingredient-item';

        var qty = ing.qty ? (ing.qty * ratio) : '';
        // Format float to nicer string (e.g. 1.5 -> 1.5, 1.0 -> 1)
        if (typeof qty === 'number') qty = parseFloat(qty.toFixed(2));

        var unit = ing.unit || '';
        var item = ing.item || '';

        var checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'pantry-check';
        checkbox.dataset.item = item;
        checkbox.addEventListener('change', function() {
            togglePantryItem(item, this.checked);
            if (this.checked) li.classList.add('in-pantry');
            else li.classList.remove('in-pantry');
        });

        var text = document.createElement('span');
        text.innerHTML = '<b>' + qty + ' ' + unit + '</b> ' + item;
        if (ing.notes) text.innerHTML += ' <em style="opacity:0.7">(' + ing.notes + ')</em>';

        li.appendChild(checkbox);
        li.appendChild(text);
        list.appendChild(li);
    });
}

function checkPantry(ingredients) {
    var pantry = JSON.parse(localStorage.getItem('pantry') || '[]');
    // Normalize pantry items
    pantry = pantry.map(i => i.toLowerCase().trim());

    var checkboxes = document.querySelectorAll('.pantry-check');
    checkboxes.forEach(function(cb) {
        var item = cb.dataset.item.toLowerCase().trim();
        // Simple fuzzy check or exact match
        if (pantry.includes(item)) {
            cb.checked = true;
            cb.closest('li').classList.add('in-pantry');
        }
    });
}

function togglePantryItem(item, isChecked) {
    var pantry = JSON.parse(localStorage.getItem('pantry') || '[]');
    var normItem = item.toLowerCase().trim();

    if (isChecked) {
        if (!pantry.includes(normItem)) pantry.push(normItem);
    } else {
        pantry = pantry.filter(i => i !== normItem);
    }

    localStorage.setItem('pantry', JSON.stringify(pantry));
}

function renderRecipeMenu(text, path) {
    var container = document.getElementById('markdownContent');
    container.innerHTML = '<h1>Recipe Menu</h1><div id="menu-loading">Loading recipes...</div>';

    // Parse links from markdown [Name](path)
    var linkRegex = /\[(.*?)\]\((.*?)\)/g;
    var match;
    var recipes = [];
    var links = [];

    while ((match = linkRegex.exec(text)) !== null) {
        links.push({ name: match[1], url: match[2] });
    }

    // Resolve relative paths
    var basePath = path.substring(0, path.lastIndexOf('/') + 1);

    // Fetch all recipes
    var promises = links.map(function(link) {
        var url = link.url;
        if (!url.startsWith('http') && !url.startsWith('/')) {
            url = basePath + url;
        }
        return fetch(url).then(res => res.text()).then(txt => {
            return { name: link.name, text: txt, url: url };
        });
    });

    Promise.all(promises).then(function(results) {
        var menuContainer = document.createElement('div');
        menuContainer.className = 'menu-container';

        var aggregatedIngredients = {};

        results.forEach(function(res) {
            // Parse Frontmatter
             if (res.text.trim().startsWith('---')) {
                var parts = res.text.split('---');
                if (parts.length >= 3 && typeof jsyaml !== 'undefined') {
                    try {
                        var fm = jsyaml.load(parts[1]);

                        // Render Recipe Card
                        var card = document.createElement('div');
                        card.className = 'menu-card';
                        card.innerHTML = '<h3>' + (fm.title || res.name) + '</h3>';
                        if (fm.image) {
                            // Fix relative path for image
                            var imgUrl = fm.image;
                             if (!imgUrl.startsWith('http') && !imgUrl.startsWith('/') && res.url.includes('/')) {
                                 var rLastSlash = res.url.lastIndexOf('/');
                                 imgUrl = res.url.substring(0, rLastSlash + 1) + imgUrl;
                             }
                             card.innerHTML += '<img src="' + imgUrl + '" style="max-width:100%; height:100px; object-fit:cover;">';
                        }
                        card.addEventListener('click', function() {
                            loadFile(res.url);
                        });
                        menuContainer.appendChild(card);

                        // Aggregate Ingredients
                        if (fm.ingredients) {
                            fm.ingredients.forEach(function(ing) {
                                var key = ing.item.toLowerCase().trim();
                                if (!aggregatedIngredients[key]) {
                                    aggregatedIngredients[key] = { ...ing, qty: 0 };
                                }
                                aggregatedIngredients[key].qty += (ing.qty || 0);
                            });
                        }
                    } catch(e) { console.error(e); }
                }
             }
        });

        container.innerHTML = '<h1>Menu: ' + path.split('/').pop().replace('.menu.md','') + '</h1>';
        container.appendChild(menuContainer);

        // Show Shopping List
        var shoppingList = document.createElement('div');
        shoppingList.className = 'shopping-list';
        shoppingList.innerHTML = '<h2>Shopping List</h2><ul>';

        for (var key in aggregatedIngredients) {
            var ing = aggregatedIngredients[key];
            shoppingList.innerHTML += '<li>' + ing.qty + ' ' + ing.unit + ' ' + ing.item + '</li>';
        }
        shoppingList.innerHTML += '</ul>';
        container.appendChild(shoppingList);

    }).catch(function(err) {
        container.innerHTML = '<div class="error-message">Error loading recipes: ' + err.message + '</div>';
    });
}
